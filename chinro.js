// Generated by CoffeeScript 1.9.3

/*
碁カーネル
中国ルールを採用。ただし自殺手は着手禁止とする。
 */

(function() {
  var BoardBase, EvaluationResult, OnBoard, base, boardOnScreen, boardsToString, cancelMessage, chase, chaseShicho, chaser, checkTarget, e, editBoard, escape, escaper, evaluatedResult, k, len, longestFail, longestSuccess, openAndCloseModal, playSequence, ref, responseInterval, root, scheduleMessage, showOnBoard, startSolve, stopEditing, target, wEvaluate;

  Array.prototype.isEqualTo = function(array) {

    /*　配列の要素すべてが等しいか否かを返す。 */
    var e, i, k, len;
    if (this.length !== array.length) {
      return false;
    }
    for (i = k = 0, len = this.length; k < len; i = ++k) {
      e = this[i];
      if (e !== array[i]) {
        return false;
      }
    }
    return true;
  };

  boardsToString = function(history) {
    return history.map(function(e, i) {
      return "#" + i + "\n" + (e.toString());
    }).join('\n');
  };

  BoardBase = (function() {
    function BoardBase(BOARD_SIZE) {
      this.BOARD_SIZE = BOARD_SIZE;
      this.BLACK = 0;
      this.WHITE = 1;
      this.EMPTY = 2;
      this.MAX_SCORE = this.BOARD_SIZE * this.BOARD_SIZE - 2;
    }

    BoardBase.prototype.opponentOf = function(stone) {

      /* 黒(BLACK)なら白(WHITE)、白(WHITE)なら黒(BLACK)を返す。 */
      switch (stone) {
        case this.BLACK:
          return this.WHITE;
        case this.WHITE:
          return this.BLACK;
        default:
          throw 'error';
      }
    };

    BoardBase.prototype.adjacenciesAt = function(position) {

      /* プライベート */

      /* 隣接する点の座標の配列を返す。 */
      var e, k, len, ref, result, x, y;
      result = [];
      ref = [[0, -1], [-1, 0], [1, 0], [0, 1]];
      for (k = 0, len = ref.length; k < len; k++) {
        e = ref[k];
        x = position[0] + e[0];
        y = position[1] + e[1];
        if ((0 <= x && x < this.BOARD_SIZE) && (0 <= y && y < this.BOARD_SIZE)) {
          result.push([x, y]);
        }
      }
      return result;
    };

    return BoardBase;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : typeof window !== "undefined" && window !== null ? window : {};

  ref = ['BoardBase', 'boardsToString'];
  for (k = 0, len = ref.length; k < len; k++) {
    e = ref[k];
    root[e] = eval(e);
  }


  /*
  碁カーネル(配列バーション)
  中国ルールを採用。ただし自殺手は着手禁止とする。
   */

  if (typeof exports !== "undefined" && exports !== null) {
    boardsToString = require('./go-common.coffee').boardsToString;
  }

  OnBoard = (function() {

    /* 盤上の状態を表すクラス */
    OnBoard.fromString = function(str, base) {

      /* 盤上の状態を表すX(黒)とO(白)と空点(スペース)と改行で文字列からインスタンスを生成する。 */
      var blacks, l, len1, line, lines, m, ref1, whites, x, y;
      blacks = [];
      whites = [];
      lines = str.replace(/(\r?\n)*$/, '').split(/\r?\n/);
      if (lines.length !== this.base.BOARD_SIZE) {
        throw 'bad format';
      }
      for (y = l = 0, len1 = lines.length; l < len1; y = ++l) {
        line = lines[y];
        if (line.length !== this.base.BOARD_SIZE) {
          throw 'bad format';
        }
        for (x = m = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? m < ref1 : m > ref1; x = 0 <= ref1 ? ++m : --m) {
          switch (line.charAt(x)) {
            case 'X':
              blacks.push([x, y]);
              break;
            case 'O':
              whites.push([x, y]);
              break;
            case ' ':
              null;
              break;
            default:
              throw 'bad format';
          }
        }
      }
      return new OnBoard(base != null ? base : new BoardBase(lines.length), blacks, whites);
    };

    OnBoard.random = function(base, boardSize) {
      var blacks, l, m, ref1, ref2, result, whites, x, y;
      if (boardSize == null) {
        boardSize = null;
      }

      /* ランダムな配置の碁盤を返す。 */
      if (base == null) {
        base = new BoardBase(boardSize);
      }
      while (true) {
        blacks = [];
        whites = [];
        for (x = l = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
          for (y = m = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? m < ref2 : m > ref2; y = 0 <= ref2 ? ++m : --m) {
            switch (Math.floor(Math.random() * 3)) {
              case 1:
                blacks.push([x, y]);
                break;
              case 2:
                whites.push([x, y]);
            }
          }
        }
        result = new OnBoard(base, blacks, whites);
        if (result.isLegal()) {
          return result;
        }
      }
    };

    function OnBoard(base1, blacks, whites) {
      var i, j, l, len1, len2, m, n, o, ref1, ref2;
      this.base = base1;

      /* blacks, whitesは黒石/白石のある場所の座標の配列。 */
      this.onBoard = new Array(this.base.BOARD_SIZE);
      for (i = l = 0, ref1 = this.onBoard.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        this.onBoard[i] = new Array(this.base.BOARD_SIZE);
        for (j = m = 0, ref2 = this.onBoard[i].length; 0 <= ref2 ? m < ref2 : m > ref2; j = 0 <= ref2 ? ++m : --m) {
          this.onBoard[i][j] = this.base.EMPTY;
        }
      }
      for (n = 0, len1 = blacks.length; n < len1; n++) {
        e = blacks[n];
        this.onBoard[e[0]][e[1]] = this.base.BLACK;
      }
      for (o = 0, len2 = whites.length; o < len2; o++) {
        e = whites[o];
        this.onBoard[e[0]][e[1]] = this.base.WHITE;
      }
    }

    OnBoard.prototype.isEmptyAt = function(position) {

      /* 座標が空点かどうか。 */
      switch (this.stateAt(position)) {
        case this.base.BLACK:
        case this.base.WHITE:
          return false;
        default:
          return true;
      }
    };

    OnBoard.prototype.isLegalAt = function(stone, position) {

      /*
      座標が合法着手点かどうか。
      コウ(循環)の着手禁止はチェックしない。循環については手順関連で別途チェックすること
       */
      var board;
      board = this.copy();
      return board.place(stone, position);
    };

    OnBoard.prototype.isLegal = function() {

      /* 盤上の状態が合法がどうか。(ダメ詰まりの石が存在しないこと) */
      var d, g, l, m, ref1, ref2, ref3, x, y;
      for (x = l = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
        for (y = m = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? m < ref2 : m > ref2; y = 0 <= ref2 ? ++m : --m) {
          if (!(!this.isEmptyAt([x, y]))) {
            continue;
          }
          ref3 = this.stringAndLibertyAt([x, y]), g = ref3[0], d = ref3[1];
          if (d.length === 0) {
            return false;
          }
        }
      }
      return true;
    };

    OnBoard.prototype.isEqualTo = function(board) {

      /* 盤上が同じかどうか。 */
      if (typeof board === 'string') {
        board = OnBoard.fromString(board);
      }
      return this.onBoard.every(function(column, i) {
        return column.isEqualTo(board.onBoard[i]);
      });
    };

    OnBoard.prototype.stateAt = function(position) {

      /* 座標の状態を返す。 */
      return this.onBoard[position[0]][position[1]];
    };

    OnBoard.prototype.numOf = function(stone) {
      var flat;
      flat = Array.prototype.concat.apply([], this.onBoard);
      return flat.filter(function(e) {
        return e === stone;
      }).length;
    };

    OnBoard.prototype.deployment = function() {

      /*
      現在の配置を返す。
      コンストラクタの逆関数
       */
      var blacks, l, m, position, ref1, ref2, whites, x, y;
      blacks = [];
      whites = [];
      for (x = l = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
        for (y = m = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? m < ref2 : m > ref2; y = 0 <= ref2 ? ++m : --m) {
          position = [x, y];
          switch (this.stateAt(position)) {
            case this.base.BLACK:
              blacks.push(position);
              break;
            case this.base.WHITE:
              whites.push(position);
          }
        }
      }
      return [blacks, whites];
    };

    OnBoard.prototype.score = function() {

      /*
      石の数の差を返す。
      中国ルールを採用。盤上の石の数の差が評価値。
       */
      return this.numOf(this.base.BLACK) - this.numOf(this.base.WHITE);
    };

    OnBoard.prototype.add = function(stone, position) {

      /*
      石を座標にセットする。
      stateは@base.BLACK, @base.WHITEのいずれか。(本当は@base.EMPTYもOK)
       */
      return this.onBoard[position[0]][position[1]] = stone;
    };

    OnBoard.prototype["delete"] = function(position) {

      /* 座標の石をただ取る。 */
      return this.add(this.base.EMPTY, position);
    };

    OnBoard.prototype.candidates = function(stone) {

      /* stoneの手番で、合法かつ自分の眼ではない座標すべての局面を返す。 */
      var board, l, m, position, ref1, ref2, result, x, y;
      result = [];
      for (x = l = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
        for (y = m = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? m < ref2 : m > ref2; y = 0 <= ref2 ? ++m : --m) {
          position = [x, y];
          if (this.whoseEyeAt(position) === stone) {
            continue;
          }
          board = this.copy();
          if (board.place(stone, position)) {
            result.push(board);
          }
        }
      }
      return result;
    };

    OnBoard.prototype.stringAndLibertyAt = function(position) {

      /*
      座標の石と接続した同一石の座標の配列とその石の集合のダメの座標の配列を返す。
      接続した石の集団を連(ストリング)と呼ぶ。
       */
      var aux, stone;
      if (this.isEmptyAt(position)) {
        return null;
      }
      stone = this.stateAt(position);
      aux = (function(_this) {
        return function(unchecked, string, liberty) {
          var adjacencies, adjacency, checking, equalPositions, l, len1;
          if (unchecked.length === 0) {
            return [string, liberty];
          }
          checking = unchecked.pop();
          adjacencies = _this.base.adjacenciesAt(checking);
          equalPositions = function(a, b) {
            return (a[0] === b[0]) && (a[1] === b[1]);
          };
          for (l = 0, len1 = adjacencies.length; l < len1; l++) {
            adjacency = adjacencies[l];
            if ((_this.stateAt(adjacency) === stone) && (string.every(function(e) {
              return !equalPositions(e, adjacency);
            }))) {
              string.push(adjacency);
              unchecked.push(adjacency);
            } else if (_this.isEmptyAt(adjacency) && (liberty.every(function(e) {
              return !equalPositions(e, adjacency);
            }))) {
              liberty.push(adjacency);
            }
          }
          return aux(unchecked, string, liberty);
        };
      })(this);
      return aux([position], [position], []);
    };

    OnBoard.prototype.stringOf = function(stones) {

      /*
      stonesのフォーマットはstringAndlibertyAtの戻り値。
      stones[0]を含むstringAndlibertyを返す
       */
      return this.stringAndLibertyAt(stones[0][0]);
    };

    OnBoard.prototype.emptyStringAt = function(position) {

      /* 座標の空点と接続した空点の座標の配列を返す。 */
      var aux;
      if (!this.isEmptyAt(position)) {
        return null;
      }
      aux = (function(_this) {
        return function(unchecked, string) {
          var adjacencies, adjacency, checking, l, len1;
          if (unchecked.length === 0) {
            return string;
          }
          checking = unchecked.pop();
          adjacencies = _this.base.adjacenciesAt(checking);
          for (l = 0, len1 = adjacencies.length; l < len1; l++) {
            adjacency = adjacencies[l];
            if (_this.isEmptyAt(adjacency) && (string.every(function(e) {
              return !e.isEqualTo(adjacency);
            }))) {
              string.push(adjacency);
              unchecked.push(adjacency);
            }
          }
          return aux(unchecked, string);
        };
      })(this);
      return aux([position], [position]);
    };

    OnBoard.prototype.emptyStrings = function() {

      /* 盤上の空点のストリングを返す。 */
      var l, m, position, ref1, ref2, result, x, y;
      result = [];
      for (x = l = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
        for (y = m = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? m < ref2 : m > ref2; y = 0 <= ref2 ? ++m : --m) {
          position = [x, y];
          if ((this.isEmptyAt(position)) && (result.every(function(s) {
            return s.every(function(e) {
              return !e.isEqualTo(position);
            });
          }))) {
            result.push(this.emptyStringAt(position));
          }
        }
      }
      return result;
    };

    OnBoard.prototype.numOfLibertiesOf = function(string) {
      return string[1].length;
    };

    OnBoard.prototype.numOfLiberties = function(stone) {
      var l, len1, len2, m, position, positions, ref1, s, strings;
      positions = [];
      strings = this.strings()[(function() {
        switch (stone) {
          case this.base.BLACK:
            return 0;
          case this.base.WHITE:
            return 1;
        }
      }).call(this)];
      for (l = 0, len1 = strings.length; l < len1; l++) {
        s = strings[l];
        ref1 = s[1];
        for (m = 0, len2 = ref1.length; m < len2; m++) {
          position = ref1[m];
          if (!positions.some(function(p) {
            return p.isEqualTo(position);
          })) {
            positions.push(position);
          }
        }
      }
      return positions.length;
    };

    OnBoard.prototype.strings = function() {

      /* 盤上のストリングを返す。1つ目の要素が黒のストリング、2つ目の要素が白のストリング。 */
      var l, m, position, ref1, ref2, result, x, y;
      result = [[], []];
      for (x = l = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
        for (y = m = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? m < ref2 : m > ref2; y = 0 <= ref2 ? ++m : --m) {
          position = [x, y];
          switch (this.stateAt(position)) {
            case this.base.BLACK:
              if (result[0].every(function(g) {
                return g[0].every(function(e) {
                  return !e.isEqualTo(position);
                });
              })) {
                result[0].push(this.stringAndLibertyAt(position));
              }
              break;
            case this.base.WHITE:
              if (result[1].every(function(g) {
                return g[0].every(function(e) {
                  return !e.isEqualTo(position);
                });
              })) {
                result[1].push(this.stringAndLibertyAt(position));
              }
          }
        }
      }
      return result;
    };

    OnBoard.prototype.isTouchedBetween = function(a, b) {

      /* ストリングa, bが接触しているかどうか。 */
      var l, len1, len2, m, p, q;
      for (l = 0, len1 = a.length; l < len1; l++) {
        p = a[l];
        for (m = 0, len2 = b.length; m < len2; m++) {
          q = b[m];
          if ((Math.abs(p[0] - q[0]) === 1) && (Math.abs(p[1] - q[1]) === 1)) {
            return true;
          }
        }
      }
      return false;
    };

    OnBoard.prototype.stringsToContacts = function(strings) {

      /* string(接続した石の集合)の配列からcontact(接続もしくは接触した石の集合)を算出して返す。 */
      var i, j, l, m, ref1, ref2, ref3, result, unique;
      result = [];
      for (i = l = 0, ref1 = strings.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        if (result[i] == null) {
          result[i] = [strings[i]];
        }
        for (j = m = ref2 = i + 1, ref3 = strings.length; ref2 <= ref3 ? m < ref3 : m > ref3; j = ref2 <= ref3 ? ++m : --m) {
          if (this.isTouchedBetween(strings[i][0], strings[j][0])) {
            result[i].push(strings[j]);
            result[j] = result[i];
          }
        }
      }
      unique = function(array) {
        var len1, n;
        result = [];
        for (n = 0, len1 = array.length; n < len1; n++) {
          e = array[n];
          if (result.indexOf(e) < 0) {
            result.push(e);
          }
        }
        return result;
      };
      return unique(result);
    };

    OnBoard.prototype.whoseEyeAt = function(position, checkings) {
      var adjacencies, gd0, gds, gds0, l, len1, stone;
      if (checkings == null) {
        checkings = [];
      }

      /*
      座標が眼かどうか調べ、眼ならばどちらの眼かを返し、眼でないならnullを返す。
      眼の定義は、その座標が同一石で囲まれていて、囲んでいる石がその座標以外のダメを詰められないこと。
      checkingsは再帰用引数
      石をかこっている時、2目以上の空点の時、眼と判定しないので改良が必要。
       */
      if (!this.isEmptyAt(position)) {
        return null;
      }
      adjacencies = this.base.adjacenciesAt(position);
      if (!(adjacencies.every((function(_this) {
        return function(e) {
          return _this.stateAt(e) === _this.base.BLACK;
        };
      })(this)) || adjacencies.every((function(_this) {
        return function(e) {
          return _this.stateAt(e) === _this.base.WHITE;
        };
      })(this)))) {
        return null;
      }
      stone = this.stateAt(adjacencies[0]);
      gds0 = adjacencies.map((function(_this) {
        return function(e) {
          return _this.stringAndLibertyAt(e);
        };
      })(this));
      gds = [];
      for (l = 0, len1 = gds0.length; l < len1; l++) {
        gd0 = gds0[l];
        if (gds.length === 0 || !(gds.some(function(gd) {
          return gd[0].some(function(e) {
            return e.isEqualTo(gd0[0][0]);
          });
        }))) {
          gds.push(gd0);
        }
      }
      if (gds.length === 1 || (gds.every((function(_this) {
        return function(gd) {
          var newCheckings;
          newCheckings = checkings.concat([position]);
          return gd[1].filter(function(e) {
            return !e.isEqualTo(position);
          }).some(function(d) {
            return checkings.some(function(e) {
              return d.isEqualTo(e);
            }) || (_this.whoseEyeAt(d, newCheckings) === stone);
          });
        };
      })(this)))) {
        return stone;
      } else {
        return null;
      }
    };

    OnBoard.prototype.eyes = function() {

      /* 眼の座標を返す。１つ目は黒の眼、２つ目は白の眼。 */
      var l, m, ref1, ref2, result, x, y;
      result = [[], []];
      for (x = l = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
        for (y = m = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? m < ref2 : m > ref2; y = 0 <= ref2 ? ++m : --m) {
          switch (this.whoseEyeAt([x, y])) {
            case this.base.BLACK:
              result[0].push([x, y]);
              break;
            case this.base.WHITE:
              result[1].push([x, y]);
          }
        }
      }
      return result;
    };

    OnBoard.prototype.copy = function() {
      var blacks, ref1, whites;
      ref1 = this.deployment(), blacks = ref1[0], whites = ref1[1];
      return new OnBoard(this.base, blacks, whites);
    };

    OnBoard.prototype.captureBy = function(position) {

      /* 座標に置かれた石によって取ることができる相手の石を取り上げて、取り上げた石の座標の配列を返す。 */
      var adjacencies, adjacency, captives, capturedStone, l, len1, len2, m, ref1, stringAndLiberty;
      capturedStone = this.base.opponentOf(this.stateAt(position));
      adjacencies = this.base.adjacenciesAt(position);
      captives = [];
      for (l = 0, len1 = adjacencies.length; l < len1; l++) {
        adjacency = adjacencies[l];
        if (!(this.stateAt(adjacency) === capturedStone)) {
          continue;
        }
        stringAndLiberty = this.stringAndLibertyAt(adjacency);
        if (stringAndLiberty[1].length === 0) {
          ref1 = stringAndLiberty[0];
          for (m = 0, len2 = ref1.length; m < len2; m++) {
            e = ref1[m];
            this["delete"](e);
          }
          captives = captives.concat(stringAndLiberty[0]);
        }
      }
      return captives;
    };

    OnBoard.prototype.place = function(stone, position) {

      /*
      石を座標に着手する。
      着手候補を減らす便宜上、自殺手は着手禁止とする。(中国ルールからの逸脱)
      着手が成立したらtrue。着手禁止の場合false。
      循環手か否かは未チェック。
       */
      var liberty, ref1, string;
      if (position == null) {
        return true;
      }
      if (!this.isEmptyAt(position)) {
        return false;
      }
      this.add(stone, position);
      this.captureBy(position);
      ref1 = this.stringAndLibertyAt(position), string = ref1[0], liberty = ref1[1];
      if (liberty.length === 0) {
        this["delete"](position);
        return false;
      }
      return true;
    };

    OnBoard.prototype.toString = function() {
      var l, m, ref1, ref2, str, x, y;
      str = '';
      for (y = l = 0, ref1 = this.base.BOARD_SIZE; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {
        for (x = m = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? m < ref2 : m > ref2; x = 0 <= ref2 ? ++m : --m) {
          str += (function() {
            switch (this.onBoard[x][y]) {
              case this.base.BLACK:
                return 'X';
              case this.base.WHITE:
                return 'O';
              default:
                return ' ';
            }
          }).call(this);
        }
        if (y !== this.base.BOARD_SIZE - 1) {
          str += '\n';
        }
      }
      return str;
    };

    OnBoard.prototype.atari = function() {
      return [];
    };

    return OnBoard;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : typeof window !== "undefined" && window !== null ? window : {};

  root.OnBoard = OnBoard;


  /*
  シチョウの結論
   */

  EvaluationResult = (function() {
    function EvaluationResult(value, history1) {
      this.value = value;
      this.history = history1;
    }

    return EvaluationResult;

  })();

  chaser = null;

  escaper = null;

  target = null;

  checkTarget = function(board) {
    var bAtaris, strings, wAtaris;
    strings = board.strings();
    bAtaris = strings[0].filter(function(e) {
      return e[1].length === 1;
    });
    wAtaris = strings[1].filter(function(e) {
      return e[1].length === 1;
    });
    return bAtaris.concat(wAtaris);
  };

  chaseShicho = function(board, targetPosition) {
    var result;
    escaper = board.stateAt(targetPosition);
    chaser = board.base.opponentOf(escaper);
    target = targetPosition;
    result = escape([board]);
    return new EvaluationResult(result.value, result.value ? longestSuccess : longestFail);

    /*
    try
        result = escape [board]
        new EvaluationResult result.value, if result.value then longestSuccess else longestFail
    catch e
        console.error e
        alert '頭が爆発しました…'
        new EvaluationResult false, longestFail
     */
  };

  longestFail = [];

  longestSuccess = [];

  escape = function(history) {
    var b, board, candidates, l, len1, len2, m, p, ref1, ref2, result, sl, strings;
    board = history[history.length - 1];
    sl = board.stringAndLibertyAt(target);
    strings = board.strings();
    candidates = [];
    ref1 = strings[chaser - 1];
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      e = ref1[l];
      if (e[1].length === 1) {
        candidates.push(e[1][0]);
      }
    }
    candidates.push(sl[1][0]);
    for (m = 0, len2 = candidates.length; m < len2; m++) {
      p = candidates[m];
      b = board.copy();
      if (!b.place(escaper, p) || ((ref2 = history[history.length - 2]) != null ? ref2.isEqualTo(b) : void 0)) {
        continue;
      }
      result = chase(history.concat(b));
      if (result.value) {
        if (longestSuccess.length < result.history.length) {
          longestSuccess = result.history;
        }
      } else {
        if (longestFail.length < result.history.length) {
          longestFail = result.history;
        }
        return result;
      }
    }
    result = chase(history.concat(board));
    if (longestSuccess.length < result.history.length) {
      longestSuccess = result.history;
    }
    return result;
  };

  chase = function(history) {
    var b, board, l, len1, p, ref1, ref2, result, sl;
    board = history[history.length - 1];
    sl = board.stringAndLibertyAt(target);
    switch (sl[1].length) {
      case 1:
        b = board.copy();
        b.place(chaser, sl[1][0]);
        history.push(b);
        if (longestSuccess.length < history.length) {
          longestSuccess = history;
        }
        return new EvaluationResult(true, history);
      case 2:
        ref1 = sl[1];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          p = ref1[l];
          b = board.copy();
          if (!b.place(chaser, p) || ((ref2 = history[history.length - 2]) != null ? ref2.isEqualTo(b) : void 0)) {
            continue;
          }
          result = escape(history.concat(b));
          if (result.value) {
            if (longestSuccess.length < result.history.length) {
              longestSuccess = result.history;
            }
            return result;
          } else {
            if (longestFail.length < result.history.length) {
              longestFail = result.history;
            }
          }
        }
        return new EvaluationResult(false, []);
      default:
        if (longestFail.length < history.length) {
          longestFail = history;
        }
        return new EvaluationResult(false, history);
    }
  };


  /*
  四路の純碁とソルバのクライアント側共通コード
   */

  responseInterval = 2000;

  wEvaluate = function(history, next, success, error, timeout) {
    var timeid, worker;
    if (timeout == null) {
      timeout = 10000;
    }

    /*
    (web workerを使って)局面を評価する。
    
    success, errorはコールバック関数。
     */
    $('#evaluating').css('display', 'inline');
    timeid = null;
    worker = new Worker('go-worker.js');
    worker.onmessage = function(event) {
      var result;
      $('#evaluating').css('display', 'none');
      clearTimeout(timeid);
      if (event.data.error != null) {
        console.log(event.data.error);
        return error(event.data.error);
      } else {
        result = new EvaluationResult(event.data.value, event.data.history.map(function(e) {
          return OnBoard.fromString(e);
        }));
        console.log(result.toString());
        return success(result);
      }
    };
    worker.postMessage({
      history: history.map(function(e) {
        return e.toString();
      }),
      next: next
    });
    return timeid = setTimeout((function() {
      $('#evaluating').css('display', 'none');
      worker.terminate();
      console.log('timeout');
      return error({
        message: 'timeout'
      });
    }), timeout);
  };

  showOnBoard = function(board, effect, callback) {
    var $intersection, ataris, blacks, deferred, deferredes, l, m, p, place, ref1, ref2, ref3, whites, x, y;
    if (effect == null) {
      effect = false;
    }
    if (callback == null) {
      callback = function() {};
    }

    /*
    boardの状態を描画する。
    boardがnullなら空の盤。
    effectをtrueにすると、今の状態からエフェクト入りで盤を変更。
     */
    if (board == null) {
      $('.intersection').removeClass('black white half-opacity beat');
      return;
    }
    ref1 = board.deployment(), blacks = ref1[0], whites = ref1[1];
    ataris = board.atari();
    deferredes = [];
    for (x = l = 0, ref2 = board.base.BOARD_SIZE; 0 <= ref2 ? l < ref2 : l > ref2; x = 0 <= ref2 ? ++l : --l) {
      for (y = m = 0, ref3 = board.base.BOARD_SIZE; 0 <= ref3 ? m < ref3 : m > ref3; y = 0 <= ref3 ? ++m : --m) {
        p = [x, y];
        $intersection = $(".intersection:nth-child(" + (1 + p[0] + p[1] * board.base.BOARD_SIZE) + ")");
        place = function(blackOrWhite, beat) {
          var deferred;
          if (effect && ((!$intersection.hasClass(blackOrWhite)) || ($intersection.hasClass('half-opacity')))) {
            deferred = $.Deferred();
            deferredes.push(deferred);
            $intersection.one($s.vendor.animationend, function() {
              var $this;
              $this = $(this);
              $this.removeClass('shake');
              if (beat) {
                $this.addClass('beat');
              } else {
                $this.removeClass('beat');
              }
              return deferred.resolve();
            });
            return $intersection.removeClass('half-opacity').addClass(blackOrWhite + " shake");
          } else {
            $intersection.removeClass('black white half-opacity').addClass(blackOrWhite);
            if (beat) {
              return $intersection.addClass('beat');
            } else {
              return $intersection.removeClass('beat');
            }
          }
        };
        if (blacks.some(function(e) {
          return e.isEqualTo(p);
        })) {
          place('black', ataris.some(function(e) {
            return e.isEqualTo(p);
          }));
        } else if (whites.some(function(e) {
          return e.isEqualTo(p);
        })) {
          place('white', ataris.some(function(e) {
            return e.isEqualTo(p);
          }));
        } else {
          if (effect && ($intersection.hasClass('black') || ($intersection.hasClass('white')))) {
            deferred = $.Deferred();
            deferredes.push(deferred);
            $intersection.removeClass('beat');
            $intersection.one($s.vendor.transitionend, (function(deferred) {
              return function() {
                $(this).removeClass('black white rise');
                return deferred.resolve();
              };
            })(deferred));
            setTimeout((function($intersection) {
              return function() {
                return $intersection.addClass('rise');
              };
            })($intersection), 100);
          } else {
            $intersection.removeClass('white black half-opacity beat');
          }
        }
      }
    }
    if (effect) {
      return $.when.apply(window, deferredes).done(callback);
    }
  };

  openAndCloseModal = function(id, callback) {
    if (callback == null) {
      callback = function() {};
    }

    /*
    モーダルを一定時間表示する。
     */
    $("#" + id).modal('show');
    return setTimeout((function() {
      $("#" + id).modal('hide');
      return callback();
    }), responseInterval);
  };


  /*
  main for solver.html
   */

  evaluatedResult = null;

  base = new BoardBase(19);

  boardOnScreen = function() {
    var blacks, whites;
    blacks = [];
    whites = [];
    $('.intersection').each(function(i, e) {
      var $e;
      $e = $(e);
      if ($e.hasClass('black')) {
        return blacks.push([i % base.BOARD_SIZE, Math.floor(i / base.BOARD_SIZE)]);
      } else if ($e.hasClass('white')) {
        return whites.push([i % base.BOARD_SIZE, Math.floor(i / base.BOARD_SIZE)]);
      }
    });
    return new OnBoard(base, blacks, whites);
  };

  editBoard = function() {
    $('#black, #white').removeAttr('disabled');
    return $('.intersection').on('click', function() {
      var $this, stone;
      $this = $(this);
      stone = $('#black-white > .active').attr('id');
      if ($this.hasClass(stone)) {
        return $this.removeClass(stone);
      } else {
        $this.removeClass('black white');
        return $this.addClass(stone);
      }
    });
  };

  stopEditing = function() {
    $('.intersection').off('click');
    return $('#black, #white').attr('disabled', 'disabled');
  };

  scheduleMessage = function() {
    var aux, messages;
    messages = [
      {
        interval: 10000,
        id: 'babble-modal1'
      }, {
        interval: 20000,
        id: 'babble-modal2'
      }, {
        interval: 30000,
        id: 'babble-modal3'
      }, {
        interval: 30000,
        id: 'babble-modal4'
      }
    ];
    aux = function(index) {
      return scheduleMessage.id = setTimeout((function() {
        openAndCloseModal(messages[index].id);
        if (index < messages.length - 1) {
          return aux(index + 1);
        }
      }), messages[index].interval);
    };
    return aux(0);
  };

  cancelMessage = function() {
    return clearTimeout(scheduleMessage.id);
  };

  playSequence = function(history) {
    var aux;
    aux = function(index) {
      return setTimeout((function() {
        if (history[index].isEqualTo(history[index - 1])) {
          openAndCloseModal(index % 2 ? 'black-pass' : 'white-pass');
        } else {
          showOnBoard(history[index], true);
        }
        if (index < history.length - 1) {
          return aux(index + 1);
        } else {
          return $('#sequence').removeAttr('disabled');
        }
      }), 100);
    };
    showOnBoard(history[0]);
    return aux(1);
  };

  $(document.body).on('touchmove', function(e) {
    if (window.Touch) {
      return e.preventDefault();
    }
  });

  $('#reset').on('click', function() {
    return $('.intersection').removeClass('black white');
  });

  startSolve = function(board, target) {
    return openAndCloseModal('start-modal', function() {
      evaluatedResult = chaseShicho(board, target);
      alert(evaluatedResult.value ? "取れました！" : "取れません…");
      $('#sequence').removeAttr('disabled');
      return editBoard();
    });
  };

  $('#solve').on('click', function() {
    var board, ps;
    stopEditing();
    board = boardOnScreen();
    ps = checkTarget(board);
    if (ps.length === 0) {
      alert('アタリの石を作ってください');
      return editBoard();
    } else if (ps.length === 1) {
      return startSolve(board, ps[0][0][0]);
    } else {
      return openAndCloseModal('target-modal', function() {
        return $('.intersection').on('click', function() {
          var index;
          $('.intersection').off('click');
          index = $('.intersection').index(this);
          return startSolve(board, [index % base.BOARD_SIZE, Math.floor(index / base.BOARD_SIZE)]);
        });
      });
    }
  });

  $('#sequence').on('click', function() {
    $(this).attr('disabled', 'disabled');
    return playSequence(evaluatedResult.history);
  });

  showOnBoard(new OnBoard(base, [[5, 1], [6, 1], [12, 1], [13, 1], [9, 5], [1, 6], [1, 7], [17, 8], [17, 9], [7, 15], [8, 15], [9, 16], [9, 17]], [[5, 0], [6, 0], [12, 0], [13, 0], [9, 2], [0, 5], [8, 5], [18, 5], [0, 6], [18, 6], [0, 7], [18, 7], [0, 8], [18, 8], [0, 9], [18, 9], [9, 14], [9, 15], [8, 16], [8, 17], [10, 17], [9, 18]]));


  /*
   * 浦壁和彦「鬼ごっこ」
  showOnBoard new OnBoard [[1,9],[2,8],[2,9],[2,10],[5,9],[7,9],[8,2],[8,8],[8,18],[9,1],[9,2],[9,5],[9,7],[9,8],[9,16],[9,17],[10,2],[10,16],[11,9],[12,10],[12,13],[12,14],[12,16],[12,17],[13,9],[13,13],[16,8],[16,9],[16,10],[17,9]]
      ,[[0,7],[0,9],[0,11],[1,6],[1,8],[1,10],[1,12],[2,5],[2,13],[3,4],[3,9],[3,14],[4,3],[4,9],[4,15],[5,2],[5,16],[6,1],[6,9],[6,17],[7,0],[7,8],[7,18],[8,1],[8,7],[9,0],[9,3],[9,4],[9,6],[9,9],[10,1],[10,7],[10,8],[10,9],[10,15],[10,17],[11,0],[11,14],[11,16],[11,18],[12,1],[12,11],[12,15],[12,18],[13,2],[13,14],[13,16],[13,17],[14,3],[14,9],[14,15],[15,4],[15,9],[15,14],[16,5],[16,13],[17,6],[17,8],[17,10],[17,12],[18,7],[18,9],[18,11]]
   */

  editBoard();

  $('#opening-modal').modal('show');

}).call(this);
