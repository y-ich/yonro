// Generated by CoffeeScript 1.11.1

/*
碁カーネル
中国ルールを採用。ただし自殺手は着手禁止とする。
 */

(function() {
  var $board, BitBoardBase, BoardBase, DEBUG, EvaluationResult, OnBoard, base, bgm, boardsToString, cache, cancelWaiting, check, compare, computerPlay, countBits, currentIndex, e, endGame, evalUntilDepth, evaluate, expected, k, l, len, len1, len2, m, onlySuicide, openAndCloseModal, ref, ref1, ref2, ref3, responseInterval, root, saveSettings, settings, showOnBoard, touchDevice, userPlayAndResponse, userStone, wEvaluate, waitForUserPlay,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Array.prototype.isEqualTo = function(array) {

    /*　配列の要素すべてが等しいか否かを返す。 */
    var e, i, k, len, ref;
    if (this.length !== array.length) {
      return false;
    }
    ref = this;
    for (i = k = 0, len = ref.length; k < len; i = ++k) {
      e = ref[i];
      if (e !== array[i]) {
        return false;
      }
    }
    return true;
  };

  boardsToString = function(history) {
    return history.map(function(e, i) {
      return "#" + i + "\n" + (e.toString());
    }).join('\n');
  };

  BoardBase = (function() {
    function BoardBase(BOARD_SIZE1) {
      this.BOARD_SIZE = BOARD_SIZE1;
      this.BLACK = 0;
      this.WHITE = 1;
      this.EMPTY = 2;
      this.MAX_SCORE = this.BOARD_SIZE * this.BOARD_SIZE - 2;
    }

    BoardBase.prototype.opponentOf = function(stone) {

      /* 黒(BLACK)なら白(WHITE)、白(WHITE)なら黒(BLACK)を返す。 */
      switch (stone) {
        case this.BLACK:
          return this.WHITE;
        case this.WHITE:
          return this.BLACK;
        default:
          throw 'error';
      }
    };

    BoardBase.prototype.adjacenciesAt = function(position) {

      /* プライベート */

      /* 隣接する点の座標の配列を返す。 */
      var e, k, len, ref, result, x, y;
      result = [];
      ref = [[0, -1], [-1, 0], [1, 0], [0, 1]];
      for (k = 0, len = ref.length; k < len; k++) {
        e = ref[k];
        x = position[0] + e[0];
        y = position[1] + e[1];
        if ((0 <= x && x < this.BOARD_SIZE) && (0 <= y && y < this.BOARD_SIZE)) {
          result.push([x, y]);
        }
      }
      return result;
    };

    return BoardBase;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : typeof window !== "undefined" && window !== null ? window : {};

  ref = ['BoardBase', 'boardsToString'];
  for (k = 0, len = ref.length; k < len; k++) {
    e = ref[k];
    root[e] = eval(e);
  }


  /*
  碁カーネル(ビットボードバージョン)
  中国ルールを採用。ただし自殺手は着手禁止とする。
   */

  if (typeof exports !== "undefined" && exports !== null) {
    ref1 = require('./go-common.coffee'), BoardBase = ref1.BoardBase, boardsToString = ref1.boardsToString;
  }

  countBits = function(x) {

    /* 32bit整数の1の数を返す */
    x -= (x >>> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
    x = (x + (x >>> 4)) & 0x0F0F0F0F;
    x += x >>> 8;
    x += x >>> 16;
    return x & 0x0000003F;
  };

  BitBoardBase = (function(superClass) {
    extend(BitBoardBase, superClass);

    function BitBoardBase(BOARD_SIZE) {
      var b, l, len1, m, n, o, ref2, ref3, ref4, ref5, x, y;
      BitBoardBase.__super__.constructor.call(this, BOARD_SIZE);
      this.BIT_BOARD_SIZE = this.BOARD_SIZE + 1;
      if (this.BIT_BOARD_SIZE * this.BOARD_SIZE > 32) {
        throw "32bit overflow";
      }
      this.BITS = [];
      for (x = l = 0, ref2 = this.BOARD_SIZE; 0 <= ref2 ? l < ref2 : l > ref2; x = 0 <= ref2 ? ++l : --l) {
        for (y = m = 0, ref3 = this.BOARD_SIZE; 0 <= ref3 ? m < ref3 : m > ref3; y = 0 <= ref3 ? ++m : --m) {
          this.BITS.push(this.positionToBit([x, y]));
        }
      }

      /*
      @BITSは位置を示すビットパターンすべての配列。
       */
      this.ON_BOARD = 0;
      ref4 = this.BITS;
      for (n = 0, len1 = ref4.length; n < len1; n++) {
        b = ref4[n];
        this.ON_BOARD |= b;
      }

      /*
      @ON_BOARDは盤上を取り出す(フレームを落とす)ためのマスク
       */
      this.BOARD_TOP = 0;
      this.BOARD_BOTTOM = 0;
      for (x = o = 0, ref5 = this.BOARD_SIZE; 0 <= ref5 ? o < ref5 : o > ref5; x = 0 <= ref5 ? ++o : --o) {
        this.BOARD_TOP |= this.positionToBit([x, 0]);
        this.BOARD_BOTTOM |= this.positionToBit([x, this.BOARD_SIZE - 1]);
      }
    }

    BitBoardBase.prototype.positionToBit = function(position) {

      /*
      positionに相当するbitboardを返す。
      bitboardのフォーマットは四路の場合、
      ....F....F....F....
      でFはフレーム(枠)
       */
      return 1 << (position[0] + position[1] * this.BIT_BOARD_SIZE);
    };

    BitBoardBase.prototype.positionsToBits = function(positions) {

      /* positions配列の位置に1を立てたビットボードを返す。 */
      var bits, l, len1;
      bits = 0;
      for (l = 0, len1 = positions.length; l < len1; l++) {
        e = positions[l];
        bits |= this.positionToBit(e);
      }
      return bits;
    };

    BitBoardBase.prototype.bitsToPositions = function(bitBoard) {

      /* ビットボード上の1の位置の配列を返す。 */
      var l, m, position, positions, ref2, ref3, x, y;
      positions = [];
      for (x = l = 0, ref2 = this.BOARD_SIZE; 0 <= ref2 ? l < ref2 : l > ref2; x = 0 <= ref2 ? ++l : --l) {
        for (y = m = 0, ref3 = this.BOARD_SIZE; 0 <= ref3 ? m < ref3 : m > ref3; y = 0 <= ref3 ? ++m : --m) {
          position = [x, y];
          if (bitBoard & this.positionToBit(position)) {
            positions.push(position);
          }
        }
      }
      return positions;
    };

    BitBoardBase.prototype.adjacent = function(bitBoard) {

      /* 呼吸点を返す。 */
      var expanded;
      expanded = bitBoard << this.BIT_BOARD_SIZE;
      expanded |= bitBoard << 1;
      expanded |= bitBoard >>> 1;
      expanded |= bitBoard >>> this.BIT_BOARD_SIZE;
      return expanded & (~bitBoard) & this.ON_BOARD;
    };

    BitBoardBase.prototype.stringOf = function(bitBoard, seed) {

      /* seedを含む連を返す。 */
      var expanded;
      if (!(bitBoard & seed)) {
        return 0;
      }
      while (true) {
        expanded = (seed | (seed << this.BIT_BOARD_SIZE) | (seed << 1) | (seed >>> 1) | (seed >>> this.BIT_BOARD_SIZE)) & bitBoard;
        if (expanded === seed) {
          return expanded;
        }
        seed = expanded;
      }
    };

    BitBoardBase.prototype.interiorOf = function(region) {

      /* 領域の内部を返す */
      var regionAndFrame;
      regionAndFrame = region | ~this.ON_BOARD;
      return region & ((region << this.BIT_BOARD_SIZE) | this.BOARD_TOP) & (regionAndFrame << 1) & (regionAndFrame >>> 1) & ((region >>> this.BIT_BOARD_SIZE) | this.BOARD_BOTTOM);
    };

    BitBoardBase.prototype.borderOf = function(region) {
      return region & ~this.interiorOf(region);
    };

    BitBoardBase.prototype.captured = function(objective, subjective) {

      /* subjectiveで囲まれたobjectiveの部分を返す。 */
      var breaths, liberty;
      liberty = this.adjacent(objective) & ~subjective;
      breaths = objective & this.adjacent(liberty);
      return objective & (~this.stringOf(objective, breaths));
    };

    BitBoardBase.prototype.decomposeToStrings = function(bitBoard) {

      /* 盤上の石をストリングに分解する。 */
      var bit, checked, l, len1, ref2, result, string;
      result = [];
      checked = 0;
      ref2 = this.BITS;
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        bit = ref2[l];
        if (!(bitBoard & ~checked & bit)) {
          continue;
        }
        string = this.stringOf(bitBoard, bit);
        result.push(string);
        checked |= string;
      }
      return result;
    };

    BitBoardBase.prototype.bitsToString = function(bitBoard) {

      /* bitBoardを文字列にする */
      var l, m, ref2, ref3, str, x, y;
      str = '';
      for (y = l = 0, ref2 = this.BOARD_SIZE; 0 <= ref2 ? l < ref2 : l > ref2; y = 0 <= ref2 ? ++l : --l) {
        for (x = m = 0, ref3 = this.BOARD_SIZE; 0 <= ref3 ? m < ref3 : m > ref3; x = 0 <= ref3 ? ++m : --m) {
          str += bitBoard & this.positionToBit([x, y]) ? 'O' : '.';
        }
        if (y !== this.BOARD_SIZE - 1) {
          str += '\n';
        }
      }
      return str;
    };

    return BitBoardBase;

  })(BoardBase);

  OnBoard = (function() {

    /* 盤上の状態を表すクラス */
    OnBoard.fromString = function(str, base) {

      /* 盤上の状態を表すX(黒)とO(白)と空点(スペース)と改行で文字列からインスタンスを生成する。 */
      var blacks, l, len1, line, lines, m, ref2, whites, x, y;
      blacks = [];
      whites = [];
      lines = str.replace(/(\r?\n)*$/, '').split(/\r?\n/);
      for (y = l = 0, len1 = lines.length; l < len1; y = ++l) {
        line = lines[y];
        for (x = m = 0, ref2 = line.length; 0 <= ref2 ? m < ref2 : m > ref2; x = 0 <= ref2 ? ++m : --m) {
          switch (line.charAt(x)) {
            case 'X':
              blacks.push([x, y]);
              break;
            case 'O':
              whites.push([x, y]);
              break;
            case ' ':
            case '.':
              null;
              break;
            default:
              throw 'bad format';
          }
        }
      }
      return new OnBoard(base != null ? base : new BitBoardBase(lines.length), blacks, whites);
    };

    OnBoard.random = function(base, density, boardSize) {
      var bitPos, blacks, l, len1, ref2, result, whites;
      if (density == null) {
        density = 1 / 2;
      }
      if (boardSize == null) {
        boardSize = null;
      }

      /* ランダムな配置の碁盤を返す。 */
      if (base == null) {
        base = new BitBoardBase(boardSize);
      }
      while (true) {
        blacks = 0;
        whites = 0;
        ref2 = base.BITS;
        for (l = 0, len1 = ref2.length; l < len1; l++) {
          bitPos = ref2[l];
          switch (Math.floor(Math.random() / density * 2)) {
            case 0:
              blacks |= bitPos;
              break;
            case 1:
              whites |= bitPos;
          }
        }
        result = new OnBoard(base, blacks, whites);
        if (result.isLegal()) {
          return result;
        }
      }
    };

    function OnBoard(base1, blacks, whites) {
      this.base = base1;

      /* blacks, whitesは黒石/白石のある場所の座標の配列。 */
      if (blacks instanceof Array && whites instanceof Array) {
        this.black = this.base.positionsToBits(blacks);
        this.white = this.base.positionsToBits(whites);
      } else if (typeof blacks === 'number' && typeof whites === 'number') {
        this.black = blacks;
        this.white = whites;
      } else {
        this.black = 0;
        this.white = 0;
      }
    }

    OnBoard.prototype.toString = function() {
      var l, m, ref2, ref3, str, x, y;
      str = '';
      for (y = l = 0, ref2 = this.base.BOARD_SIZE; 0 <= ref2 ? l < ref2 : l > ref2; y = 0 <= ref2 ? ++l : --l) {
        for (x = m = 0, ref3 = this.base.BOARD_SIZE; 0 <= ref3 ? m < ref3 : m > ref3; x = 0 <= ref3 ? ++m : --m) {
          str += (function() {
            switch (this.stateAt([x, y])) {
              case this.base.BLACK:
                return 'X';
              case this.base.WHITE:
                return 'O';
              default:
                return ' ';
            }
          }).call(this);
        }
        if (y !== this.base.BOARD_SIZE - 1) {
          str += '\n';
        }
      }
      return str;
    };

    OnBoard.prototype.isEqualTo = function(board) {

      /* 盤上が同じかどうか。 */
      if (typeof board === 'string') {
        board = OnBoard.fromString(board);
      }
      return this.black === board.black && this.white === board.white;
    };

    OnBoard.prototype.isEmptyAt = function(position) {

      /* 座標が空点かどうか。 */
      return this._isEmptyAt(this.base.positionToBit(position));
    };

    OnBoard.prototype.isLegalAt = function(stone, position) {

      /*
      座標が合法着手点かどうか。
      コウ(循環)の着手禁止はチェックしない。循環については手順関連で別途チェックすること
       */
      var board;
      board = this.copy();
      return board.place(stone, position);
    };

    OnBoard.prototype.isLegal = function() {

      /* 盤上の状態が合法がどうか。(ダメ詰まりの石が存在しないこと) */
      return this.base.captured(this.black, this.white) === 0 && this.base.captured(this.white, this.black) === 0;
    };

    OnBoard.prototype.stateAt = function(position) {

      /* 座標の状態を返す。 */
      return this._stateAt(this.base.positionToBit(position));
    };

    OnBoard.prototype.numOf = function(stone) {

      /* 盤上の石または空点の数を返す。 */
      return countBits((function() {
        switch (stone) {
          case this.base.BLACK:
            return this.black;
          case this.base.WHITE:
            return this.white;
          case this.base.EMPTY:
            return this._empties();
          default:
            throw 'numOf';
            return 0;
        }
      }).call(this));
    };

    OnBoard.prototype.deployment = function() {

      /*
      現在の配置を返す。
      コンストラクタの逆関数
       */
      return [this.base.bitsToPositions(this.black), this.base.bitsToPositions(this.white)];
    };

    OnBoard.prototype.score = function() {

      /*
      石の数の差を返す。
      中国ルールを採用。盤上の石の数の差が評価値。
       */
      return countBits(this.black) - countBits(this.white);
    };

    OnBoard.prototype.add = function(stone, position) {

      /*
      石を座標にセットする。
      stateはBLACK, WHITEのいずれか。(本当はEMPTYもOK)
       */
      return this._add(stone, this.base.positionToBit(position));
    };

    OnBoard.prototype["delete"] = function(position) {

      /* 座標の石をただ取る。 */
      return this._delete(this.base.positionToBit(position));
    };

    OnBoard.prototype.candidates = function(stone) {

      /*
      stoneの手番で、合法かつ自分の眼ではない座標に打った局面を返す。
      合法かつ自分の眼ではない座標がない場合、生きている石の目を埋める。
       */
      var bitPos, board, c, closures, enclosedRegion, eyes, l, len1, len2, len3, m, n, ref2, result;
      result = [];
      ref2 = this.base.BITS;
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        bitPos = ref2[l];
        if (this._whoseEyeAt(bitPos, true) === stone) {
          continue;
        }
        board = this.copy();
        if (board._place(stone, bitPos)) {
          result.push(board);
        }
      }
      if (result.length > 0) {
        return result;
      }
      closures = this.closureAndRegionsOf(stone);
      enclosedRegion = this.enclosedRegionOf(stone);
      for (m = 0, len2 = closures.length; m < len2; m++) {
        c = closures[m];
        eyes = this.base.decomposeToStrings(c & enclosedRegion);
        if (eyes.length > 2) {
          for (n = 0, len3 = eyes.length; n < len3; n++) {
            e = eyes[n];
            board = this.copy();
            if (board._place(stone, e)) {
              result.push(board);
            }
          }
        }
      }
      return result;
    };

    OnBoard.prototype.stringAt = function(position) {
      return this.stringOf(this.base.positionToBit(position));
    };

    OnBoard.prototype.stringAndLibertyAt = function(position) {

      /*
      座標の石と接続した同一石の座標の配列とその石の集合のダメの座標の配列を返す。
      接続した石の集団を連(ストリング)と呼ぶ。
       */
      var s;
      s = this.stringAt(position);
      return [s, this._libertyOf(s)];
    };

    OnBoard.prototype.numOfLibertiesOf = function(string) {
      return countBits(this._libertyOf(string));
    };

    OnBoard.prototype._empties = function() {
      return this.base.ON_BOARD & ~(this.black | this.white);
    };

    OnBoard.prototype.emptyStrings = function() {

      /* 盤上の空点のストリングを返す。 */
      return this.base.decomposeToStrings(this._empties());
    };

    OnBoard.prototype.numOfLiberties = function(stone) {
      var lib, opponent, self;
      switch (stone) {
        case this.base.BLACK:
          self = this.black;
          opponent = this.white;
          break;
        case this.base.WHITE:
          self = this.white;
          opponent = this.black;
      }
      lib = this.base.adjacent(self) & ~opponent;
      return countBits(lib);
    };

    OnBoard.prototype.strings = function() {

      /* 盤上のストリングを返す。1つ目の要素が黒のストリング、2つ目の要素が白のストリング。 */
      return [this.stringsOf(this.base.BLACK), this.stringsOf(this.base.WHITE)];
    };

    OnBoard.prototype.stringsOf = function(stone) {
      return this.base.decomposeToStrings((function() {
        switch (stone) {
          case this.base.BLACK:
            return this.black;
          case this.base.WHITE:
            return this.white;
        }
      }).call(this));
    };

    OnBoard.prototype.isTouchedBetween = function(a, b) {

      /* ストリングa, bが接触しているかどうか。 */
      return (this.base.adjacent(a) | b) !== 0;
    };

    OnBoard.prototype.stringsToContacts = function(strings) {

      /* string(接続した石の集合)の配列からcontact(接続もしくは接触した石の集合)を算出して返す。 */
      var i, j, l, m, ref2, ref3, ref4, result, unique;
      result = [];
      for (i = l = 0, ref2 = strings.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        if (result[i] == null) {
          result[i] = [strings[i]];
        }
        for (j = m = ref3 = i + 1, ref4 = strings.length; ref3 <= ref4 ? m < ref4 : m > ref4; j = ref3 <= ref4 ? ++m : --m) {
          if (this.isTouchedBetween(strings[i], strings[j])) {
            result[i].push(strings[j]);
            result[j] = result[i];
          }
        }
      }
      unique = function(array) {
        var len1, n;
        result = [];
        for (n = 0, len1 = array.length; n < len1; n++) {
          e = array[n];
          if (result.indexOf(e) < 0) {
            result.push(e);
          }
        }
        return result;
      };
      return unique(result);
    };

    OnBoard.prototype.whoseEyeAt = function(position, genuine) {
      if (genuine == null) {
        genuine = false;
      }
      return this._whoseEyeAt(this.base.positionToBit(position), genuine);
    };

    OnBoard.prototype.eyesOf = function(stone) {
      var bEnclosed, bitBoard, empties, every, l, len1, len2, m, r, regions, result, s, strings;
      result = [];
      bEnclosed = this.enclosedRegionOf(stone);
      regions = this.base.decomposeToStrings(bEnclosed);
      bitBoard = (function() {
        switch (stone) {
          case this.base.BLACK:
            return this.black;
          case this.base.WHITE:
            return this.white;
        }
      }).call(this);
      for (l = 0, len1 = regions.length; l < len1; l++) {
        r = regions[l];
        strings = this.base.decomposeToStrings(this.base.stringOf(bitBoard, this.base.adjacent(r)));
        empties = r & this._empties();

        /*
        if strings.every((s) => (empties & @base.adjacent s) is empties)
            result.push r
         */
        every = true;
        for (m = 0, len2 = strings.length; m < len2; m++) {
          s = strings[m];
          if ((empties & this.base.adjacent(s)) !== empties) {
            every = false;
            break;
          }
        }
        if (every) {
          result.push(r);
        }
      }
      return result;
    };

    OnBoard.prototype.eyes = function() {

      /* 眼の座標を返す。１つ目は黒の眼、２つ目は白の眼。 */
      var b, blackOnly, blacks, every, l, len1, len2, len3, len4, m, n, o, w, whiteOnly, whites;
      blacks = this.eyesOf(this.base.BLACK);
      whites = this.eyesOf(this.base.WHITE);
      blackOnly = [];
      for (l = 0, len1 = blacks.length; l < len1; l++) {
        b = blacks[l];
        every = true;
        for (m = 0, len2 = whites.length; m < len2; m++) {
          w = whites[m];
          if (w & b) {
            every = false;
            break;
          }
        }
        if (every) {
          blackOnly.push(b);
        }
      }
      whiteOnly = [];
      for (n = 0, len3 = whites.length; n < len3; n++) {
        w = whites[n];
        every = true;
        for (o = 0, len4 = blacks.length; o < len4; o++) {
          b = blacks[o];
          if (w & b) {
            every = false;
            break;
          }
        }
        if (every) {
          whiteOnly.push(w);
        }
      }
      return [blackOnly, whiteOnly];
    };

    OnBoard.prototype.atari = function() {
      return this.base.bitsToPositions(this._atari());
    };

    OnBoard.prototype.enclosedRegionOf = function(stone) {
      var interiors, opponent, regions, self;
      switch (stone) {
        case this.base.BLACK:
          self = this.black;
          opponent = this.white;
          break;
        case this.base.WHITE:
          self = this.white;
          opponent = this.black;
      }
      regions = ~self & this.base.ON_BOARD;
      interiors = this.base.interiorOf(regions);
      return regions & ~this.base.stringOf(regions, interiors & ~opponent);
    };

    OnBoard.prototype.closureAndRegionsOf = function(stone) {
      var neighoring, region;
      region = this.enclosedRegionOf(stone);
      neighoring = this.base.stringOf(((function() {
        switch (stone) {
          case this.base.BLACK:
            return this.black;
          case this.base.WHITE:
            return this.white;
        }
      }).call(this)), this.base.adjacent(region));
      return this.base.decomposeToStrings(neighoring | region);
    };

    OnBoard.prototype._atari = function() {
      var l, len1, result, s, strings;
      result = 0;
      strings = [].concat.apply([], this.strings());
      for (l = 0, len1 = strings.length; l < len1; l++) {
        s = strings[l];
        if (this.numOfLibertiesOf(s) === 1) {
          result |= s;
        }
      }
      return result;
    };

    OnBoard.prototype.copy = function() {
      return new OnBoard(this.base, this.black, this.white);
    };

    OnBoard.prototype.captureBy = function(stone) {

      /* 相手の石を取り上げて、取り上げた石のビットボードを返す。 */
      var captives;
      switch (stone) {
        case this.base.BLACK:
          captives = this.base.captured(this.white, this.black);
          this.white &= ~captives;
          break;
        case this.base.WHITE:
          captives = this.base.captured(this.black, this.white);
          this.black &= ~captives;
      }
      return captives;
    };

    OnBoard.prototype.place = function(stone, position) {

      /*
      石を座標に着手する。
      着手候補を減らす便宜上、自殺手は着手禁止とする。(中国ルールからの逸脱)
      着手が成立したらtrue。着手禁止の場合false。
      循環手か否かは未チェック。
       */
      if (position == null) {
        return true;
      }
      return this._place(stone, this.base.positionToBit(position));
    };

    OnBoard.prototype._stateAt = function(bitPos) {
      if (this.black & bitPos) {
        return this.base.BLACK;
      } else if (this.white & bitPos) {
        return this.base.WHITE;
      } else {
        return this.base.EMPTY;
      }
    };

    OnBoard.prototype._add = function(stone, bitPos) {
      switch (stone) {
        case this.base.BLACK:
          this.black |= bitPos;
          this.white &= ~bitPos;
          break;
        case this.base.WHITE:
          this.white |= bitPos;
          this.black &= ~bitPos;
          break;
        case this.base.EMPTY:
          this.black &= ~bitPos;
          this.white &= ~bitPos;
          break;
        default:
          throw 'add: unknown stone type';
      }
    };

    OnBoard.prototype._delete = function(bitPos) {
      this.black &= ~bitPos;
      return this.white &= ~bitPos;
    };

    OnBoard.prototype._isEmptyAt = function(bitPos) {

      /* 座標が空点かどうか。 */
      return !((this.black | this.white) & bitPos);
    };

    OnBoard.prototype._place = function(stone, bitPos) {
      if (!this._isEmptyAt(bitPos)) {
        return false;
      }
      this._add(stone, bitPos);
      this.captureBy(stone);
      if (this.isLegal()) {
        return true;
      } else {
        this._delete(bitPos);
        return false;
      }
    };

    OnBoard.prototype.stringOf = function(bitPos) {
      var board;
      board = (function() {
        switch (this._stateAt(bitPos)) {
          case this.base.BLACK:
            return this.black;
          case this.base.WHITE:
            return this.white;
          default:
            return this._empties();
        }
      }).call(this);
      return this.base.stringOf(board, bitPos);
    };

    OnBoard.prototype._libertyOf = function(string) {
      var opponent;
      opponent = this.black & string ? this.white : this.black;
      return this.base.adjacent(string) & ~opponent;
    };

    OnBoard.prototype._whoseEyeAt = function(bitPos, genuine, checkings, bEnclosed, wEnclosed) {
      var b, bitBoard, cont, every, gd, gds, l, len1, len2, liberty, m, ref2, region, stone;
      if (genuine == null) {
        genuine = false;
      }
      if (checkings == null) {
        checkings = 0;
      }
      if (bEnclosed == null) {
        bEnclosed = null;
      }
      if (wEnclosed == null) {
        wEnclosed = null;
      }

      /*
      座標が眼かどうか調べ、眼ならばどちらの眼かを返し、眼でないならnullを返す。
      眼の定義は、その座標が同一石で囲まれていて、囲んでいる石がその座標以外のダメを詰められないこと。
      checkingsは再帰用引数
      石をかこっている時、2目以上の空点の時、眼と判定しないので改良が必要。
       */
      if (!this._isEmptyAt(bitPos)) {
        return null;
      }
      if (bEnclosed == null) {
        bEnclosed = this.enclosedRegionOf(this.base.BLACK);
      }
      if (bEnclosed & bitPos) {
        stone = this.base.BLACK;
        bitBoard = this.black;
        region = this.base.stringOf(bEnclosed, bitPos);
      } else {
        if (wEnclosed == null) {
          wEnclosed = this.enclosedRegionOf(this.base.WHITE);
        }
        if (wEnclosed & bitPos) {
          stone = this.base.WHITE;
          bitBoard = this.white;
          region = this.base.stringOf(wEnclosed, bitPos);
        } else {
          return null;
        }
      }
      if (genuine && countBits(region) > 1) {
        return null;
      }
      gds = this.base.decomposeToStrings(this.base.stringOf(bitBoard, this.base.adjacent(region)));

      /*
      if gds.length == 1 or # 眼を作っている石群が1つ
          (gds.every (gd) =>
              liberty = @base.adjacent(gd) & ~region
              return true if liberty & checkings
              return true for b in @base.BITS when (b & liberty) and @_whoseEyeAt(b, genuine, checkings | bitPos, bEnclosed, wEnclosed) is stone
              false)
          stone
      else
          null
       * 以下のチューンで2m17が2m15
       */
      if (gds.length === 1) {
        return stone;
      } else {
        every = true;
        for (l = 0, len1 = gds.length; l < len1; l++) {
          gd = gds[l];
          liberty = this.base.adjacent(gd) & ~region;
          if (liberty & checkings) {
            continue;
          }
          cont = false;
          ref2 = this.base.BITS;
          for (m = 0, len2 = ref2.length; m < len2; m++) {
            b = ref2[m];
            if ((b & liberty) && this._whoseEyeAt(b, genuine, checkings | bitPos, bEnclosed, wEnclosed) === stone) {
              cont = true;
              break;
            }
          }
          if (cont) {
            continue;
          }
          every = false;
          break;
        }
        if (every) {
          return stone;
        } else {
          return null;
        }
      }
    };

    return OnBoard;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : typeof window !== "undefined" && window !== null ? window : {};

  root.OnBoard = OnBoard;

  root.BitBoardBase = BitBoardBase;

  if (typeof exports !== "undefined" && exports !== null) {
    ref2 = ['countBits'];
    for (l = 0, len1 = ref2.length; l < len1; l++) {
      e = ref2[l];
      if (typeof exports !== "undefined" && exports !== null) {
        root[e] = eval(e);
      }
    }
  }


  /*
  局面評価
  中国ルールを採用。ただし自殺手は着手禁止とする。
   */

  if (typeof exports !== "undefined" && exports !== null) {
    boardsToString = require('./go-common.coffee').boardsToString;
    BitBoardBase = require('./bit-board.coffee').BitBoardBase;
  }

  DEBUG = false;

  check = function(board, next) {
    return ((next == null) || next === board.base.BLACK) && board.isEqualTo(' XXX\nOXOX\nOXOX\nOOO ');
  };

  cache = {
    black: [],
    white: [],
    clear: function() {
      this.black = [];
      return this.white = [];
    },
    add: function(next, board, result) {
      var array;
      array = (function() {
        switch (next) {
          case board.base.BLACK:
            return this.black;
          case board.base.WHITE:
            return this.white;
        }
      }).call(this);
      array.push({
        board: board,
        result: result
      });
    },
    query: function(next, board) {
      var array, index, len2, m;
      array = (function() {
        switch (next) {
          case board.base.BLACK:
            return this.black;
          case board.base.WHITE:
            return this.white;
        }
      }).call(this);
      for (m = 0, len2 = array.length; m < len2; m++) {
        e = array[m];
        if (!(e.board.isEqualTo(board))) {
          continue;
        }
        index = e.result.history.indexOf(e.board);
        return new EvaluationResult(e.result.value, e.result.history.slice(index + 1));
      }
      return null;
    }
  };

  evaluate = function(history, next) {
    var depth, m, ref3, result, trueEnd;
    cache.clear();
    result = evalUntilDepth(history, next, 0);
    trueEnd = !isNaN(result.value);
    if (DEBUG) {
      console.log("trueEnd: " + trueEnd);
    }
    for (depth = m = 2, ref3 = (trueEnd ? 5 : 1); m <= 30; depth = m += ref3) {
      if (DEBUG) {
        console.log("depth: " + depth);
      }
      result = evalUntilDepth(history, next, depth, trueEnd);
      if (DEBUG) {
        console.log(result.toString());
      }
      if (!isNaN(result.value)) {
        return result;
      }
    }
    return result;
  };

  compare = function(a, b, stone) {

    /*
    探索のための優先順位を決める局面比較関数。
    a, bは比較する局面。stoneの立場で比較し、結果を整数値で返す。
    
    0. 相手の石が0
    1. 自分の眼の数に差があればそれを返す。(眼形が多い手を優先する)
    2. スコアに差があればそれを返す。(石を取った手を優先する)
    3. 自分のダメの数と相手のダメの数の差に差があればそれを返す。(攻め合いに有効な手を優先する)
    4. 自分の連(string)の数に差があればそれにマイナスを掛けた値を返す。(つながる手を優先する)
    5. 自分のつながり(contact)の数に差があればそれにマイナスを掛けた値を返す。(つながる手を優先する)
     */
    var aBlack, aWhite, bBlack, bWhite, dame, diff, opponent, ref3, ref4, score, strings;
    opponent = a.base.opponentOf(stone);

    /*
    candidates = - a.candidates(opponent).length + b.candidates(opponent).length
    if candidates != 0
        return candidates
     */
    ref3 = a.strings(), aBlack = ref3[0], aWhite = ref3[1];
    ref4 = b.strings(), bBlack = ref4[0], bWhite = ref4[1];
    switch (stone) {
      case a.base.BLACK:
        dame = (a.numOfLiberties(a.base.BLACK) - a.numOfLiberties(a.base.WHITE)) - (b.numOfLiberties(b.base.BLACK) - b.numOfLiberties(b.base.WHITE));
        if (dame !== 0) {
          return dame;
        }
        strings = bBlack.length - aBlack.length;
        if (strings !== 0) {
          return strings;
        }
        aBlack = a.stringsToContacts(aBlack);
        bBlack = b.stringsToContacts(bBlack);
        diff = bBlack.length - aBlack.length;
        if (diff !== 0) {
          return diff;
        }
        score = a.score() - b.score();
        return score;
      case a.base.WHITE:
        dame = (a.numOfLiberties(a.base.WHITE) - a.numOfLiberties(a.base.BLACK)) - (b.numOfLiberties(b.base.WHITE) - b.numOfLiberties(b.base.BLACK));
        if (dame !== 0) {
          return dame;
        }
        strings = bWhite.length - aWhite.length;
        if (strings !== 0) {
          return strings;
        }
        aWhite = a.stringsToContacts(aWhite);
        bWhite = b.stringsToContacts(bWhite);
        diff = bWhite.length - aWhite.length;
        if (diff !== 0) {
          return diff;
        }
        score = b.score() - a.score();
        return score;
    }
  };

  onlySuicide = function(nodes, next, board) {
    var blacks, ref3, strings, suicides, whites;
    ref3 = board.strings(), blacks = ref3[0], whites = ref3[1];
    strings = (function() {
      switch (next) {
        case board.base.BLACK:
          return blacks;
        case board.base.WHITE:
          return whites;
      }
    })();
    suicides = nodes.filter(function(b) {
      return strings.some(function(e) {
        return board.numOfLibertiesOf(e) > 1 && b.numOfLibertiesOf(b.stringOf(e)) === 1;
      });
    });
    return suicides.length === nodes.length;
  };

  EvaluationResult = (function() {
    function EvaluationResult(value, history1) {
      this.value = value;
      this.history = history1;
    }

    EvaluationResult.prototype.copy = function() {
      return new EvaluationResult(this.value, this.history);
    };

    EvaluationResult.prototype.toString = function() {
      return ("value: " + this.value + "\n") + 'history:\n' + boardsToString(this.history);
    };

    return EvaluationResult;

  })();

  evalUntilDepth = function(history, next, depth, trueEnd, alpha, beta) {
    var b, board, c, candidates, empty, eyeBoard, eyes, flag, i, len2, len3, m, n, nan, nodes, notPossibleToIterate, opponent, parity, result, updated;
    if (trueEnd == null) {
      trueEnd = false;
    }
    if (alpha == null) {
      alpha = new EvaluationResult(-2e308, []);
    }
    if (beta == null) {
      beta = new EvaluationResult(2e308, []);
    }

    /*
    historyはOnBoardインスタンスの配列
    historyの最終局面の評価値と評価値に至る手順を返す。
    nextは次の手番。
    depthは最大深度。反復進化パラメータ
    alpha, betaはαβ枝狩りパラメータ
    外部関数compareが肝。
     */
    board = history[history.length - 1];
    if (DEBUG && check(board, next)) {
      flag = true;
    }
    if ((board === history[history.length - 2]) && (board === history[history.length - 3])) {
      return new EvaluationResult(board.score(), history);
    }
    if (!trueEnd) {
      empty = board._empties();
      eyes = board.eyes();
      eyeBoard = eyes[0].reduce((function(x, y) {
        return x | y;
      }), 0);
      if ((empty & eyeBoard) === empty || (board.numOf(board.base.WHITE) === 0 && (eyes[0].length >= 2 || board.numOf(board.base.EMPTY) > 6))) {
        return new EvaluationResult(board.base.MAX_SCORE, history);
      }
      eyeBoard = eyes[1].reduce((function(x, y) {
        return x | y;
      }), 0);
      if ((empty & eyeBoard) === empty || (board.numOf(board.base.BLACK) === 0 && (eyes[1].length >= 2 || board.numOf(board.base.EMPTY) > 6))) {
        return new EvaluationResult(-board.base.MAX_SCORE, history);
      }
    }
    if (depth <= 0) {
      return new EvaluationResult(0/0, history);
    }
    opponent = board.base.opponentOf(next);
    candidates = board.candidates(next);
    parity = history.length % 2;
    nodes = candidates.filter(function(b) {
      return history.filter(function(e, i) {
        return (i % 2) === parity;
      }).every(function(e) {
        return !b.isEqualTo(e);
      });
    });
    notPossibleToIterate = candidates.length === nodes.length;
    c = cache.query(next, board);
    if ((c != null) && notPossibleToIterate) {
      return new EvaluationResult(c.value, history.concat(c.history));
    }
    nodes.sort(function(a, b) {
      return -compare(a, b, next);
    });
    if (onlySuicide(nodes, next, board)) {
      nodes.push(board);
    }
    nan = null;
    updated = false;
    switch (next) {
      case board.base.BLACK:
        for (i = m = 0, len2 = nodes.length; m < len2; i = ++m) {
          b = nodes[i];
          result = evalUntilDepth(history.concat(b), opponent, (b === board ? depth : depth - 1), trueEnd, alpha, beta);
          if (flag) {
            console.log('nodes');
            console.log(b.toString());
            console.log(result.toString());
          }
          if ((result.value > alpha.value) || (result.value === alpha.value && result.history.length < alpha.history.length)) {
            alpha = result;
          } else if (isNaN(result.value)) {
            if (nan == null) {
              nan = result;
            }
          }
          if (alpha.value >= beta.value) {
            return beta;
          }
        }
        if ((nan != null) && alpha.value < board.base.MAX_SCORE) {
          return nan;
        }
        if (notPossibleToIterate && history.every(function(e, i) {
          return e === alpha.history[i];
        })) {
          cache.add(next, board, alpha);
        }
        if (alpha.value === -2e308) {
          return nan;
        } else {
          return alpha;
        }
      case board.base.WHITE:
        for (i = n = 0, len3 = nodes.length; n < len3; i = ++n) {
          b = nodes[i];
          result = evalUntilDepth(history.concat(b), opponent, (b === board ? depth : depth - 1), trueEnd, alpha, beta);
          if (flag) {
            console.log('nodes');
            console.log(b.toString());
            console.log(result.toString());
          }
          if ((result.value < beta.value) || (result.value === beta.value && result.history.length < beta.history.length)) {
            beta = result;
          } else if (isNaN(result.value)) {
            if (nan == null) {
              nan = result;
            }
          }
          if (alpha.value >= beta.value) {
            return alpha;
          }
        }
        if ((nan != null) && beta.value > -board.base.MAX_SCORE) {
          return nan;
        }
        if (notPossibleToIterate && history.every(function(e, i) {
          return e === beta.history[i];
        })) {
          cache.add(next, board, beta);
        }
        if (beta.value === 2e308) {
          return nan;
        } else {
          return beta;
        }
    }
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : typeof window !== "undefined" && window !== null ? window : {};

  ref3 = ['compare', 'evaluate'];
  for (m = 0, len2 = ref3.length; m < len2; m++) {
    e = ref3[m];
    root[e] = eval(e);
  }


  /*
  四路の純碁とソルバのクライアント側共通コード
   */

  responseInterval = 2000;

  wEvaluate = function(history, next, success, error, timeout) {
    var timeid, worker;
    if (timeout == null) {
      timeout = 10000;
    }

    /*
    (web workerを使って)局面を評価する。
    
    success, errorはコールバック関数。
     */
    $('#evaluating').css('display', 'inline');
    timeid = null;
    worker = new Worker('go-worker.js');
    worker.onmessage = function(event) {
      var result;
      $('#evaluating').css('display', 'none');
      clearTimeout(timeid);
      if (event.data.error != null) {
        console.log(event.data.error);
        return error(event.data.error);
      } else {
        result = new EvaluationResult(event.data.value, event.data.history.map(function(e) {
          return OnBoard.fromString(e);
        }));
        console.log(result.toString());
        return success(result);
      }
    };
    worker.postMessage({
      history: history.map(function(e) {
        return e.toString();
      }),
      next: next
    });
    return timeid = setTimeout((function() {
      $('#evaluating').css('display', 'none');
      worker.terminate();
      console.log('timeout');
      return error({
        message: 'timeout'
      });
    }), timeout);
  };

  showOnBoard = function(board, effect, callback) {
    var $intersection, ataris, blacks, deferred, deferredes, n, o, p, place, ref4, ref5, ref6, whites, x, y;
    if (effect == null) {
      effect = false;
    }
    if (callback == null) {
      callback = function() {};
    }

    /*
    boardの状態を描画する。
    boardがnullなら空の盤。
    effectをtrueにすると、今の状態からエフェクト入りで盤を変更。
     */
    if (board == null) {
      $('.intersection').removeClass('black white half-opacity beat');
      return;
    }
    ref4 = board.deployment(), blacks = ref4[0], whites = ref4[1];
    ataris = board.atari();
    deferredes = [];
    for (x = n = 0, ref5 = board.base.BOARD_SIZE; 0 <= ref5 ? n < ref5 : n > ref5; x = 0 <= ref5 ? ++n : --n) {
      for (y = o = 0, ref6 = board.base.BOARD_SIZE; 0 <= ref6 ? o < ref6 : o > ref6; y = 0 <= ref6 ? ++o : --o) {
        p = [x, y];
        $intersection = $(".intersection:nth-child(" + (1 + p[0] + p[1] * board.base.BOARD_SIZE) + ")");
        place = function(blackOrWhite, beat) {
          var deferred;
          if (effect && ((!$intersection.hasClass(blackOrWhite)) || ($intersection.hasClass('half-opacity')))) {
            deferred = $.Deferred();
            deferredes.push(deferred);
            $intersection.one($s.vendor.animationend, function() {
              var $this;
              $this = $(this);
              $this.removeClass('shake');
              if (beat) {
                $this.addClass('beat');
              } else {
                $this.removeClass('beat');
              }
              return deferred.resolve();
            });
            return $intersection.removeClass('half-opacity').addClass(blackOrWhite + " shake");
          } else {
            $intersection.removeClass('black white half-opacity').addClass(blackOrWhite);
            if (beat) {
              return $intersection.addClass('beat');
            } else {
              return $intersection.removeClass('beat');
            }
          }
        };
        if (blacks.some(function(e) {
          return e.isEqualTo(p);
        })) {
          place('black', ataris.some(function(e) {
            return e.isEqualTo(p);
          }));
        } else if (whites.some(function(e) {
          return e.isEqualTo(p);
        })) {
          place('white', ataris.some(function(e) {
            return e.isEqualTo(p);
          }));
        } else {
          if (effect && ($intersection.hasClass('black') || ($intersection.hasClass('white')))) {
            deferred = $.Deferred();
            deferredes.push(deferred);
            $intersection.removeClass('beat');
            $intersection.one($s.vendor.transitionend, (function(deferred) {
              return function() {
                $(this).removeClass('black white rise');
                return deferred.resolve();
              };
            })(deferred));
            setTimeout((function($intersection) {
              return function() {
                return $intersection.addClass('rise');
              };
            })($intersection), 100);
          } else {
            $intersection.removeClass('white black half-opacity beat');
          }
        }
      }
    }
    if (effect) {
      return $.when.apply(window, deferredes).done(callback);
    }
  };

  openAndCloseModal = function(id, callback) {
    if (callback == null) {
      callback = function() {};
    }

    /*
    モーダルを一定時間表示する。
     */
    $("#" + id).modal('show');
    return setTimeout((function() {
      $("#" + id).modal('hide');
      return callback();
    }), responseInterval);
  };


  /*
   * 四路の碁(仮名)
   * (C) 2013 ICHIKAWA, Yuji (New 3 Rs)
   */

  userStone = null;

  base = new BitBoardBase(4);

  expected = null;

  currentIndex = 0;

  if (localStorage['yonro'] != null) {
    settings = JSON.parse(localStorage['yonro']);
    $('#music-off').prop('checked', settings['music-off']);
  }

  saveSettings = function() {
    return localStorage['yonro'] = JSON.stringify({
      'music-off': $('#music-off').prop('checked')
    });
  };

  try {
    document.createEvent("TouchEvent");
    if ((window.Touch != null) && (typeof window.ontouchstart) !== 'undefined') {
      touchDevice = true;
    } else {
      false;
    }
  } catch (error1) {
    touchDevice = false;
  }

  window.printExpected = function() {
    return console.log(expected.toString());
  };

  bgm = {
    element: $('#bgm')[0],
    state: 'stop',
    play: function() {
      if ($('#music-off').prop('checked')) {
        return;
      }
      bgm.element.volume = 0.1;
      bgm.element.play();
      return bgm.state = 'play';
    },
    pause: function() {
      if (bgm.state === 'play') {
        bgm.element.pause();
        return bgm.state = 'pause';
      }
    },
    stop: function() {
      bgm.element.pause();
      bgm.state = 'stop';
      try {
        return bgm.element.currentTime = 0;
      } catch (error1) {
        e = error1;
        return console.log(e);
      }
    }
  };

  window.onpagehide = function() {
    if (bgm.state === 'play') {
      return bgm.pause();
    }
  };

  window.onpageshow = function() {
    if (bgm.state === 'pause') {
      return bgm.play();
    }
  };

  endGame = function() {
    var score;
    bgm.stop();
    score = expected.value;
    alert(score === 0 ? '引き分け' : score > 0 ? "黒" + score + "目勝ち" : "白" + (-score) + "目勝ち");
    return $('#start-stop').removeAttr('disabled');
  };

  computerPlay = function(board) {
    var behaveNext, ref4, ref5, score;
    behaveNext = function() {
      currentIndex += 1;
      if (currentIndex < expected.history.length) {
        if (board.isEqualTo(expected.history[currentIndex])) {
          return setTimeout((function() {
            var ref4, ref5;
            alert('パスします');
            if (((ref4 = expected.history[currentIndex - 2]) != null ? ref4.isEqualTo(board) : void 0) && ((ref5 = expected.history[currentIndex - 1]) != null ? ref5.isEqualTo(board) : void 0)) {
              return endGame();
            } else {
              return waitForUserPlay();
            }
          }), 0);
        } else {
          return showOnBoard(expected.history[currentIndex], true, waitForUserPlay);
        }
      } else {
        return endGame();
      }
    };
    if ((ref4 = expected.history[currentIndex]) != null ? ref4.isEqualTo(board) : void 0) {
      if (expected.history.length - 1 > currentIndex) {
        if (!((ref5 = expected.history[currentIndex - 1]) != null ? ref5.isEqualTo(board) : void 0)) {
          score = expected.value;
          score = userStone === base.BLACK ? -score : score;
          if (score > 0) {
            return openAndCloseModal('expect-modal', behaveNext);
          } else if (expected.value === (userStone === base.BLACK ? base.MAX_SCORE : -base.MAX_SCORE) && expected.history[expected.history.length - 1].numOf(base.opponentOf(userStone)) === 0) {
            bgm.stop();
            return setTimeout((function() {
              alert('負けました…');
              return $('#start-stop').removeAttr('disabled');
            }), responseInterval);
          } else if (score < 0) {
            return openAndCloseModal('pessimistic-modal', behaveNext);
          } else {
            return setTimeout((function() {
              return behaveNext();
            }), responseInterval);
          }
        } else if (expected.value === (userStone === base.BLACK ? base.MAX_SCORE : -base.MAX_SCORE) && expected.history[expected.history.length - 1].numOf(base.opponentOf(userStone)) === 0) {
          bgm.stop();
          return setTimeout((function() {
            alert('負けました…');
            return $('#start-stop').removeAttr('disabled');
          }), responseInterval);
        } else {
          return setTimeout((function() {
            return behaveNext();
          }), responseInterval);
        }
      } else if (expected.value === (userStone === base.BLACK ? base.MAX_SCORE : -base.MAX_SCORE)) {
        bgm.stop();
        return setTimeout((function() {
          alert('負けました…');
          return $('#start-stop').removeAttr('disabled');
        }), responseInterval);
      } else {
        $('#unexpected-modal').modal('show');
        return wEvaluate(expected.history.slice(0, currentIndex).concat(board), base.opponentOf(userStone), (function(result) {
          expected = result;
          if (expected.value === (userStone === base.BLACK ? base.MAX_SCORE : -base.MAX_SCORE) && expected.history[expected.history.length - 1].numOf(base.opponentOf(userStone)) === 0) {
            bgm.stop();
            return setTimeout((function() {
              alert('負けました…');
              return $('#start-stop').removeAttr('disabled');
            }), responseInterval);
          } else {
            return behaveNext();
          }
        }), (function(error) {
          var b, candidates, computerStone, len3, n, nodes, parity;
          $('#evaluate-modal').modal('hide');
          expected = {
            value: 0/0,
            history: expected.history.slice(0, currentIndex).concat(board)
          };
          computerStone = base.opponentOf(userStone);
          candidates = board.candidates(computerStone);
          nodes = [];
          for (n = 0, len3 = candidates.length; n < len3; n++) {
            b = candidates[n];
            parity = userStone === base.BLACK ? 0 : 1;
            if (expected.history.filter(function(e, i) {
              return (i % 2) === parity;
            }).every(function(e) {
              return !b.isEqualTo(e);
            })) {
              nodes.push(b);
            }
          }
          nodes.sort(function(a, b) {
            return -compare(a, b, computerStone);
          });
          expected.history.push(nodes[0]);
          return openAndCloseModal('upset-modal', behaveNext);
        }));
      }
    } else {
      return wEvaluate(expected.history.slice(0, currentIndex).concat(board), base.opponentOf(userStone), (function(result) {
        expected = result;
        return behaveNext();
      }), (function(error) {
        var b, candidates, computerStone, len3, n, nodes, parity;
        expected = {
          value: 0/0,
          history: expected.history.slice(0, currentIndex).concat(board)
        };
        computerStone = base.opponentOf(userStone);
        candidates = board.candidates(computerStone);
        nodes = [];
        for (n = 0, len3 = candidates.length; n < len3; n++) {
          b = candidates[n];
          parity = userStone === base.BLACK ? 0 : 1;
          if (expected.history.filter(function(e, i) {
            return (i % 2) === parity;
          }).every(function(e) {
            return !b.isEqualTo(e);
          })) {
            nodes.push(b);
          }
        }
        nodes.sort(function(a, b) {
          return -compare(a, b, computerStone);
        });
        expected.history.push(nodes[0]);
        return behaveNext();
      }));
    }
  };

  userPlayAndResponse = function(position) {
    var board, parity;
    $('#pass, #resign').attr('disabled', 'disabled');
    board = expected.history[currentIndex].copy();
    if (board.place(userStone, position)) {
      parity = (currentIndex + 1) % 2;
      if ((position != null) && expected.history.slice(0, currentIndex).filter(function(e, i) {
        return (i % 2) === parity;
      }).some(function(e) {
        return board.isEqualTo(e);
      })) {
        alert('そこへ打つと繰り返し…');
        showOnBoard(expected.history[currentIndex]);
        return waitForUserPlay();
      } else {
        return showOnBoard(board, true, function() {
          currentIndex += 1;
          return computerPlay(board);
        });
      }
    } else {
      alert('そこは打てないよ〜');
      showOnBoard(expected.history[currentIndex]);
      return waitForUserPlay();
    }
  };

  $board = $('#board');

  if (touchDevice) {
    $(document.body).on('touchmove', function(e) {
      return e.preventDefault();
    });
    waitForUserPlay = function() {
      $board.on('touchstart', '.intersection:not(.black):not(.white)', function() {
        $board.off('touchstart', '.intersection:not(.black):not(.white)');
        $(this).addClass((userStone === base.BLACK ? 'black' : 'white') + " half-opacity");
        $board.on('touchmove', function(e) {
          var $target, event;
          event = e.originalEvent;
          $target = $(document.elementFromPoint(event.touches[0].clientX, event.touches[0].clientY));
          if ($target.is('.intersection:not(.black):not(.white)')) {
            $target.parent().children('.half-opacity').removeClass('black white half-opacity');
            return $target.addClass((userStone === base.BLACK ? 'black' : 'white') + " half-opacity");
          }
        });
        return $board.on('touchend touchcancel', function(e) {
          var $target, event, index;
          $board.off('touchmove touchend touchcancel');
          if (e.type === 'touchcancel') {
            return;
          }
          event = e.originalEvent;
          $target = $(document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY));
          if ($target.is('.intersection.half-opacity')) {
            index = $target.prevAll().length;
            return userPlayAndResponse.call(this, [index % base.BOARD_SIZE, Math.floor(index / base.BOARD_SIZE)]);
          }
        });
      });
      return $('#pass, #resign').removeAttr('disabled');
    };
    cancelWaiting = function() {
      $board.off('touchstart', '.intersection:not(.black):not(.white)');
      return $board.off('touchmove touchend touchcancel');
    };
  } else {
    waitForUserPlay = function() {
      $board.on('mousedown', '.intersection:not(.black):not(.white)', function() {
        $board.off('mousedown', '.intersection:not(.black):not(.white)');
        $(this).addClass((userStone === base.BLACK ? 'black' : 'white') + " half-opacity");
        $board.on('mouseleave', '.intersection.half-opacity', function() {
          return $(this).removeClass('black white half-opacity');
        });
        $board.on('mouseenter', '.intersection:not(.black):not(.white)', function() {
          return $(this).addClass((userStone === base.BLACK ? 'black' : 'white') + " half-opacity");
        });
        return $board.on('mouseup', '.intersection.half-opacity', function() {
          var index;
          $board.off('mouseleave', '.intersection.half-opacity');
          $board.off('mouseenter', '.intersection:not(.black):not(.white)');
          $board.off('mouseup', '.intersection.half-opacity');
          index = $(this).prevAll().length;
          return userPlayAndResponse.call(this, [index % base.BOARD_SIZE, Math.floor(index / base.BOARD_SIZE)]);
        });
      });
      return $('#pass, #resign').removeAttr('disabled');
    };
    cancelWaiting = function() {
      $board.off('mousedown', '.intersection:not(.black):not(.white)');
      $board.off('mouseleave', '.intersection.half-opacity');
      $board.off('mouseenter', '.intersection:not(.black):not(.white)');
      return $board.off('mouseup', '.intersection.half-opacity');
    };
  }

  $('#start-stop').on('click', function() {
    var board;
    showOnBoard(null);
    board = new OnBoard.random(base);
    expected = {
      value: 0/0,
      history: [board]
    };
    currentIndex = 0;
    showOnBoard(expected.history[currentIndex]);
    return setTimeout((function() {
      return $('#select-modal').modal('show');
    }), 3000);
  });

  $('#play-white, #play-black').on('click', function() {
    $('#start-stop').attr('disabled', 'disabled');
    userStone = (function() {
      switch (this.id) {
        case 'play-white':
          return base.WHITE;
        case 'play-black':
          return base.BLACK;
        default:
          return null;
      }
    }).call(this);
    bgm.play();
    return openAndCloseModal('start-modal', function() {
      if (userStone === base.BLACK) {
        return waitForUserPlay();
      } else {
        return computerPlay(expected.history[currentIndex]);
      }
    });
  });

  $('#pass').on('click', function() {
    cancelWaiting();
    return userPlayAndResponse(null);
  });

  $('#resign').on('click', function() {
    cancelWaiting();
    bgm.stop();
    return openAndCloseModal('end-modal', function() {
      $('#start-stop').removeAttr('disabled');
      return $('#pass, #resign').attr('disabled', 'disabled');
    });
  });

  $('#music-off').on('change', function() {
    if ($(this).prop('checked')) {
      bgm.pause();
    } else if ($('#start-stop').prop('disabled')) {
      bgm.play();
    }
    return saveSettings();
  });

}).call(this);
