// Generated by CoffeeScript 1.8.0

/*
碁カーネル(ビッとボードバージョン)
中国ルールを採用。ただし自殺手は着手禁止とする。
 */

(function() {
  var $board, BIT_BOARD_SIZE, BLACK, BOARD_SIZE, EMPTY, MAX_SCORE, ON_BOARD, OnBoard, WHITE, adjacent, bgm, bitsToPositions, bitsToString, boardsToString, cancelWaiting, captured, compare, computerPlay, countBits, currentIndex, decomposeToStrings, e, endGame, expected, openAndCloseModal, opponentOf, positionToBit, positionsToBits, responseInterval, root, showOnBoard, stringOf, touchDevice, userPlayAndResponse, userStone, wEvaluate, waitForUserPlay, _BITS, _i, _len, _ref, _ref1;

  if (typeof exports !== "undefined" && exports !== null) {
    _ref = require('./go-common.coffee'), BLACK = _ref.BLACK, WHITE = _ref.WHITE, EMPTY = _ref.EMPTY, MAX_SCORE = _ref.MAX_SCORE, BOARD_SIZE = _ref.BOARD_SIZE, MAX_SCORE = _ref.MAX_SCORE, opponentOf = _ref.opponentOf, boardsToString = _ref.boardsToString, compare = _ref.compare;
  }

  positionToBit = function(position) {

    /*
    positionに相当するbitboardを返す。
    bitboardのフォーマットは四路の場合、
    ....F....F....F....
    でFはフレーム(枠)
     */
    return 1 << (position[0] + position[1] * BIT_BOARD_SIZE);
  };

  BIT_BOARD_SIZE = BOARD_SIZE + 1;

  if (BIT_BOARD_SIZE * BOARD_SIZE > 32) {
    throw "overflow " + (BIT_BOARD_SIZE * BOARD_SIZE);
  }

  _BITS = (function() {
    var result, x, y, _i, _j;
    result = [];
    for (x = _i = 0; 0 <= BOARD_SIZE ? _i < BOARD_SIZE : _i > BOARD_SIZE; x = 0 <= BOARD_SIZE ? ++_i : --_i) {
      for (y = _j = 0; 0 <= BOARD_SIZE ? _j < BOARD_SIZE : _j > BOARD_SIZE; y = 0 <= BOARD_SIZE ? ++_j : --_j) {
        result.push(positionToBit([x, y]));
      }
    }
    return result;
  })();


  /*
  _BITSは位置を示すビットパターンすべての配列。
   */

  ON_BOARD = (function() {
    var b, result, _i, _len;
    result = 0;
    for (_i = 0, _len = _BITS.length; _i < _len; _i++) {
      b = _BITS[_i];
      result |= b;
    }
    return result;
  })();


  /*
  ON_BOARDは盤上を取り出す(フレームを落とす)ためのマスク
   */

  countBits = function(x) {

    /*
    32bit整数の1の数を返す。
     */
    x -= (x >>> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
    x = (x + (x >>> 4)) & 0x0F0F0F0F;
    x += x >>> 8;
    x += x >>> 16;
    return x & 0x0000003F;
  };

  positionsToBits = function(positions) {

    /*
    positions配列の位置に1を立てたビットボードを返す。
     */
    var bits, e, _i, _len;
    bits = 0;
    for (_i = 0, _len = positions.length; _i < _len; _i++) {
      e = positions[_i];
      bits |= positionToBit(e);
    }
    return bits;
  };

  bitsToPositions = function(bitBoard) {

    /*
    ビットボード上の1の位置の配列を返す
     */
    var position, positions, x, y, _i, _j;
    positions = [];
    for (x = _i = 0; 0 <= BOARD_SIZE ? _i < BOARD_SIZE : _i > BOARD_SIZE; x = 0 <= BOARD_SIZE ? ++_i : --_i) {
      for (y = _j = 0; 0 <= BOARD_SIZE ? _j < BOARD_SIZE : _j > BOARD_SIZE; y = 0 <= BOARD_SIZE ? ++_j : --_j) {
        position = [x, y];
        if (bitBoard & positionToBit(position)) {
          positions.push(position);
        }
      }
    }
    return positions;
  };

  adjacent = function(bitBoard) {
    var expanded;
    expanded = bitBoard << BIT_BOARD_SIZE;
    expanded |= bitBoard << 1;
    expanded |= bitBoard >>> 1;
    expanded |= bitBoard >>> BIT_BOARD_SIZE;
    return expanded & (~bitBoard) & ON_BOARD;
  };

  stringOf = function(bitBoard, seed) {
    var expanded;
    if (!(bitBoard & seed)) {
      return 0;
    }
    expanded = seed | (adjacent(seed)) & bitBoard;
    if (expanded === seed) {
      return seed;
    } else {
      return stringOf(bitBoard, expanded);
    }
  };

  captured = function(objective, subjective) {
    var breaths, l;
    l = adjacent(objective) & ~subjective;
    breaths = objective & adjacent(l);
    return objective & (~stringOf(objective, breaths));
  };

  decomposeToStrings = function(bitBoard) {

    /* 盤上の石をストリングに分解する。 */
    var bit, result, _i, _len;
    result = [];
    for (_i = 0, _len = _BITS.length; _i < _len; _i++) {
      bit = _BITS[_i];
      if ((bitBoard & bit) && result.every(function(b) {
        return (b & bit) === 0;
      })) {
        result.push(stringOf(bitBoard, bit));
      }
    }
    return result;
  };

  bitsToString = function(bitBoard, char) {
    var str, x, y, _i, _j;
    str = '';
    for (y = _i = 0; 0 <= BOARD_SIZE ? _i < BOARD_SIZE : _i > BOARD_SIZE; y = 0 <= BOARD_SIZE ? ++_i : --_i) {
      for (x = _j = 0; 0 <= BOARD_SIZE ? _j < BOARD_SIZE : _j > BOARD_SIZE; x = 0 <= BOARD_SIZE ? ++_j : --_j) {
        str += bitBoard & positionToBit([x, y]) ? 'O' : '.';
      }
      if (y !== BOARD_SIZE - 1) {
        str += '\n';
      }
    }
    return str;
  };

  OnBoard = (function() {

    /* 盤上の状態を表すクラス */
    OnBoard.fromString = function(str) {

      /* 盤上の状態を表すX(黒)とO(白)と空点(スペース)と改行で文字列からインスタンスを生成する。 */
      var blacks, line, lines, whites, x, y, _i, _j, _len;
      blacks = [];
      whites = [];
      lines = str.replace(/(\r?\n)*$/, '').split(/\r?\n/);
      if (lines.length !== BOARD_SIZE) {
        throw 'bad format';
      }
      for (y = _i = 0, _len = lines.length; _i < _len; y = ++_i) {
        line = lines[y];
        if (line.length !== BOARD_SIZE) {
          throw 'bad format';
        }
        for (x = _j = 0; 0 <= BOARD_SIZE ? _j < BOARD_SIZE : _j > BOARD_SIZE; x = 0 <= BOARD_SIZE ? ++_j : --_j) {
          switch (line.charAt(x)) {
            case 'X':
              blacks.push([x, y]);
              break;
            case 'O':
              whites.push([x, y]);
              break;
            case ' ':
              null;
              break;
            default:
              throw 'bad format';
          }
        }
      }
      return new OnBoard(blacks, whites);
    };

    OnBoard.random = function() {

      /* ランダムな配置の碁盤を返す。 */
      var bitPos, blacks, result, whites, _i, _len;
      while (true) {
        blacks = 0;
        whites = 0;
        for (_i = 0, _len = _BITS.length; _i < _len; _i++) {
          bitPos = _BITS[_i];
          switch (Math.floor(Math.random() * 3)) {
            case 1:
              blacks |= bitPos;
              break;
            case 2:
              whites |= bitPos;
          }
        }
        result = new OnBoard(blacks, whites);
        if (result.isLegal()) {
          return result;
        }
      }
    };

    function OnBoard(blacks, whites) {

      /* blacks, whitesは黒石/白石のある場所の座標の配列。 */
      if (blacks instanceof Array && whites instanceof Array) {
        this.black = positionsToBits(blacks);
        this.white = positionsToBits(whites);
      } else if (typeof blacks === 'number' && typeof whites === 'number') {
        this.black = blacks;
        this.white = whites;
      } else {
        this.black = 0;
        this.white = 0;
      }
    }

    OnBoard.prototype.isEmptyAt = function(position) {

      /* 座標が空点かどうか。 */
      return this._isEmptyAt(positionToBit(position));
    };

    OnBoard.prototype._isEmptyAt = function(bitPos) {

      /* 座標が空点かどうか。 */
      return !((this.black | this.white) & bitPos);
    };

    OnBoard.prototype.isLegalAt = function(stone, position) {

      /*
      座標が合法着手点かどうか。
      コウ(循環)の着手禁止はチェックしない。循環については手順関連で別途チェックすること
       */
      var board;
      board = this.copy();
      return board.place(stone, position);
    };

    OnBoard.prototype.isLegal = function() {

      /* 盤上の状態が合法がどうか。(ダメ詰まりの石が存在しないこと) */
      return captured(this.black, this.white) === 0 && captured(this.white, this.black) === 0;
    };

    OnBoard.prototype.isEqualTo = function(board) {

      /* 盤上が同じかどうか。 */
      if (typeof board === 'string') {
        board = OnBoard.fromString(board);
      }
      return this.black === board.black && this.white === board.white;
    };

    OnBoard.prototype.stateAt = function(position) {

      /* 座標の状態を返す。 */
      return this._stateAt(positionToBit(position));
    };

    OnBoard.prototype._stateAt = function(bitPos) {
      if (this.black & bitPos) {
        return BLACK;
      } else if (this.white & bitPos) {
        return WHITE;
      } else {
        return EMPTY;
      }
    };

    OnBoard.prototype.numOf = function(stone) {
      switch (stone) {
        case BLACK:
          return countBits(this.black);
        case WHITE:
          return countBits(this.white);
        default:
          throw 'numOf';
          return 0;
      }
    };

    OnBoard.prototype.deployment = function() {

      /*
      現在の配置を返す。
      コンストラクタの逆関数
       */
      return [bitsToPositions(this.black, bitsToPositions(this.white))];
    };

    OnBoard.prototype.score = function() {

      /*
      石の数の差を返す。
      中国ルールを採用。盤上の石の数の差が評価値。
       */
      return countBits(this.black) - countBits(this.white);
    };

    OnBoard.prototype.add = function(stone, position) {

      /*
      石を座標にセットする。
      stateはBLACK, WHITEのいずれか。(本当はEMPTYもOK)
       */
      return this._add(stone, positionToBit(position));
    };

    OnBoard.prototype._add = function(stone, bitPos) {
      switch (stone) {
        case BLACK:
          this.black |= bitPos;
          this.white &= ~bitPos;
          break;
        case WHITE:
          this.white |= bitPos;
          this.black &= ~bitPos;
          break;
        case EMPTY:
          this.black &= ~bitPos;
          this.white &= ~bitPos;
          break;
        default:
          throw 'add: unknown stone type';
      }
    };

    OnBoard.prototype["delete"] = function(position) {

      /* 座標の石をただ取る。 */
      return this._delete(positionToBit(position));
    };

    OnBoard.prototype._delete = function(bitPos) {
      this.black &= ~bitPos;
      return this.white &= ~bitPos;
    };

    OnBoard.prototype.candidates = function(stone) {

      /* stoneの手番で、合法かつ自分の眼ではない座標に打った局面を返す。 */
      var bitPos, board, result, _i, _len;
      result = [];
      for (_i = 0, _len = _BITS.length; _i < _len; _i++) {
        bitPos = _BITS[_i];
        if (this._whoseEyeAt(bitPos, true) === stone) {
          continue;
        }
        board = this.copy();
        if (board._place(stone, bitPos)) {
          result.push(board);
        }
      }
      return result;
    };

    OnBoard.prototype.stringAt = function(position) {
      return this._stringAt(positionToBit(position));
    };

    OnBoard.prototype._stringAt = function(bitPos) {
      var board;
      board = (function() {
        switch (this._stateAt(bitPos)) {
          case BLACK:
            return this.black;
          case WHITE:
            return this.white;
          default:
            return ~(this.black | this.white);
        }
      }).call(this);
      return stringOf(board, bitPos);
    };

    OnBoard.prototype.stringAndLibertyAt = function(position) {

      /*
      座標の石と接続した同一石の座標の配列とその石の集合のダメの座標の配列を返す。
      接続した石の集団を連(ストリング)と呼ぶ。
       */
      var s;
      s = this.stringAt(position);
      return [s, this._libertyOf(s)];
    };

    OnBoard.prototype._libertyOf = function(string) {
      var opponent;
      opponent = this.black & string ? this.white : this.black;
      return adjacent(string) & ~opponent;
    };

    OnBoard.prototype._numOfLibertiesOf = function(string) {
      return countBits(this._libertyOf(string));
    };

    OnBoard.prototype.numOfEmpties = function() {
      return countBits(ON_BOARD & ~(this.black | this.white));
    };

    OnBoard.prototype.emptyStrings = function() {

      /* 盤上の空点のストリングを返す。 */
      var bitPos, result, _i, _len;
      result = [];
      for (_i = 0, _len = _BITS.length; _i < _len; _i++) {
        bitPos = _BITS[_i];
        if ((this._isEmptyAt(bitPos)) && (result.every(function(s) {
          return !(s & bitPos);
        }))) {
          result.push(this._stringAt(bitPos));
        }
      }
      return result;
    };

    OnBoard.prototype.numOfLiberties = function(stone) {
      var lib, opponent, self;
      switch (stone) {
        case BLACK:
          self = this.black;
          opponent = this.white;
          break;
        case WHITE:
          self = this.white;
          opponent = this.black;
      }
      lib = adjacent(self) & ~opponent;
      return countBits(lib);
    };

    OnBoard.prototype.strings = function() {

      /* 盤上のストリングを返す。1つ目の要素が黒のストリング、2つ目の要素が白のストリング。 */
      return [decomposeToStrings(this.black), decomposeToStrings(this.white)];
    };

    OnBoard.prototype.isTouchedBetween = function(a, b) {

      /* ストリングa, bが接触しているかどうか。 */
      return (adjacent(a) | b) !== 0;
    };

    OnBoard.prototype.stringsToContacts = function(strings) {

      /* string(接続した石の集合)の配列からcontact(接続もしくは接触した石の集合)を算出して返す。 */
      var i, j, result, unique, _i, _j, _ref1, _ref2, _ref3;
      result = [];
      for (i = _i = 0, _ref1 = strings.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        if (result[i] == null) {
          result[i] = [strings[i]];
        }
        for (j = _j = _ref2 = i + 1, _ref3 = strings.length; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; j = _ref2 <= _ref3 ? ++_j : --_j) {
          if (this.isTouchedBetween(strings[i], strings[j])) {
            result[i].push(strings[j]);
            result[j] = result[i];
          }
        }
      }
      unique = function(array) {
        var e, _k, _len;
        result = [];
        for (_k = 0, _len = array.length; _k < _len; _k++) {
          e = array[_k];
          if (result.indexOf(e) < 0) {
            result.push(e);
          }
        }
        return result;
      };
      return unique(result);
    };

    OnBoard.prototype.whoseEyeAt = function(position, genuine) {
      if (genuine == null) {
        genuine = false;
      }

      /*
      座標が眼かどうか調べ、眼ならばどちらの眼かを返し、眼でないならnullを返す。
      眼の定義は、その座標が同一石で囲まれていて、囲んでいる石がその座標以外のダメを詰められないこと。
      checkingsは再帰用引数
      石をかこっている時、2目以上の空点の時、眼と判定しないので改良が必要。
       */
      return this._whoseEyeAt(positionToBit(position), genuine);
    };

    OnBoard.prototype._whoseEyeAt = function(bitPos, genuine, checkings) {
      var adj, bitBoard, emptyString, gds, stone, strings;
      if (genuine == null) {
        genuine = false;
      }
      if (checkings == null) {
        checkings = 0;
      }

      /*
      座標が眼かどうか調べ、眼ならばどちらの眼かを返し、眼でないならnullを返す。
      眼の定義は、その座標が同一石で囲まれていて、囲んでいる石がその座標以外のダメを詰められないこと。
      checkingsは再帰用引数
      石をかこっている時、2目以上の空点の時、眼と判定しないので改良が必要。
       */
      if (!this._isEmptyAt(bitPos)) {
        return null;
      }
      emptyString = this._stringAt(bitPos);
      if (countBits(emptyString) >= 8) {
        return null;
      }
      adj = adjacent(emptyString);
      if (adj === 0) {
        stone = null;
      } else if ((adj & this.black) === adj) {
        stone = BLACK;
        bitBoard = this.black;
      } else if ((adj & this.white) === adj) {
        stone = WHITE;
        bitBoard = this.white;
      } else if (!genuine && (adj & (this.black | this.white)) === adj) {
        strings = decomposeToStrings(stringOf(this.white, adj & this.white));
        if (strings.length === 1 && countBits(adjacent(strings[0]) & ~this.black) === 1 && decomposeToStrings(stringOf(this.black, adj & this.black)).map((function(_this) {
          return function(e) {
            return countBits(_this._libertyOf(e));
          };
        })(this)).every(function(e) {
          return e > 1;
        })) {
          return BLACK;
        }
        strings = decomposeToStrings(stringOf(this.black, adj & this.black));
        if (strings.length === 1 && countBits(adjacent(strings[0]) & ~this.white) === 1 && decomposeToStrings(stringOf(this.white, adj & this.white)).map((function(_this) {
          return function(e) {
            return countBits(_this._libertyOf(e));
          };
        })(this)).every(function(e) {
          return e > 1;
        })) {
          return WHITE;
        }
        stone = null;
        bitBoard = null;
      } else {
        stone = null;
        bitBoard = null;
      }
      if (stone == null) {
        return null;
      }
      gds = decomposeToStrings(stringOf(bitBoard, adj));
      if (gds.length === 1 || (gds.every((function(_this) {
        return function(gd) {
          var b, liberty, _i, _len;
          liberty = adjacent(gd) & ~bitPos;
          if (liberty & checkings) {
            return true;
          }
          for (_i = 0, _len = _BITS.length; _i < _len; _i++) {
            b = _BITS[_i];
            if ((b & liberty) && _this._whoseEyeAt(b, genuine, checkings | bitPos) === stone) {
              return true;
            }
          }
          return false;
        };
      })(this)))) {
        return stone;
      } else {
        return null;
      }
    };

    OnBoard.prototype.eyes = function() {

      /* 眼の座標を返す。１つ目は黒の眼、２つ目は白の眼。 */
      var bitPos, result, _i, _len;
      result = [[], []];
      for (_i = 0, _len = _BITS.length; _i < _len; _i++) {
        bitPos = _BITS[_i];
        switch (this._whoseEyeAt(bitPos)) {
          case BLACK:
            result[0].push(bitPos);
            break;
          case WHITE:
            result[1].push(bitPos);
        }
      }
      return result;
    };

    OnBoard.prototype.copy = function() {
      return new OnBoard(this.black, this.white);
    };

    OnBoard.prototype.captureBy = function(stone) {

      /* 相手の石を取り上げて、取り上げた石のビットボードを返す。 */
      var captives;
      switch (stone) {
        case BLACK:
          captives = captured(this.white, this.black);
          this.white &= ~captives;
          break;
        case WHITE:
          captives = captured(this.black, this.white);
          this.black &= ~captives;
      }
      return captives;
    };

    OnBoard.prototype.place = function(stone, position) {

      /*
      石を座標に着手する。
      着手候補を減らす便宜上、自殺手は着手禁止とする。(中国ルールからの逸脱)
      着手が成立したらtrue。着手禁止の場合false。
      循環手か否かは未チェック。
       */
      if (position == null) {
        return true;
      }
      return this._place(stone, positionToBit(position));
    };

    OnBoard.prototype._place = function(stone, bitPos) {
      if (!this._isEmptyAt(bitPos)) {
        return false;
      }
      this._add(stone, bitPos);
      this.captureBy(stone);
      if (this.isLegal()) {
        return true;
      } else {
        this._delete(bitPos);
        return false;
      }
    };

    OnBoard.prototype.toString = function() {
      var str, x, y, _i, _j;
      str = '';
      for (y = _i = 0; 0 <= BOARD_SIZE ? _i < BOARD_SIZE : _i > BOARD_SIZE; y = 0 <= BOARD_SIZE ? ++_i : --_i) {
        for (x = _j = 0; 0 <= BOARD_SIZE ? _j < BOARD_SIZE : _j > BOARD_SIZE; x = 0 <= BOARD_SIZE ? ++_j : --_j) {
          str += (function() {
            switch (this.stateAt([x, y])) {
              case BLACK:
                return 'X';
              case WHITE:
                return 'O';
              default:
                return ' ';
            }
          }).call(this);
        }
        if (y !== BOARD_SIZE - 1) {
          str += '\n';
        }
      }
      return str;
    };

    return OnBoard;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.OnBoard = OnBoard;

  if (typeof exports !== "undefined" && exports !== null) {
    _ref1 = ['countBits', 'positionToBit', 'positionsToBits', 'bitsToPositions', 'adjacent', 'stringOf', 'captured', 'decomposeToStrings', 'boardsToString', 'compare'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      e = _ref1[_i];
      if (typeof exports !== "undefined" && exports !== null) {
        root[e] = eval(e);
      }
    }
  }


  /*
  四路の純碁とソルバのクライアント側共通コード
   */

  responseInterval = 2000;

  wEvaluate = function(history, next, success, error, timeout) {
    var timeid, worker;
    if (timeout == null) {
      timeout = 10000;
    }

    /*
    (web workerを使って)局面を評価する。
    
    success, errorはコールバック関数。
     */
    $('#evaluating').css('display', 'inline');
    timeid = null;
    worker = new Worker('go-worker.js');
    worker.onmessage = function(event) {
      $('#evaluating').css('display', 'none');
      clearTimeout(timeid);
      if (event.data.error != null) {
        return error(event.data.error);
      } else {
        return success({
          value: event.data.value,
          history: event.data.history.map(function(e) {
            return OnBoard.fromString(e);
          })
        });
      }
    };
    worker.postMessage({
      history: history.map(function(e) {
        return e.toString();
      }),
      next: next
    });
    return timeid = setTimeout((function() {
      $('#evaluating').css('display', 'none');
      worker.terminate();
      return error({
        message: 'timeout'
      });
    }), timeout);
  };

  showOnBoard = function(board, effect, callback) {
    var $intersection, blacks, deferred, deferredes, p, place, whites, x, y, _j, _k, _ref2;
    if (effect == null) {
      effect = false;
    }
    if (callback == null) {
      callback = function() {};
    }

    /*
    boardの状態を描画する。
    boardがnullなら空の盤。
    effectをtrueにすると、今の状態からエフェクト入りで盤を変更。
     */
    if (board == null) {
      $('.intersection').removeClass('black white half-opacity');
      return;
    }
    _ref2 = board.deployment(), blacks = _ref2[0], whites = _ref2[1];
    deferredes = [];
    for (x = _j = 0; 0 <= BOARD_SIZE ? _j < BOARD_SIZE : _j > BOARD_SIZE; x = 0 <= BOARD_SIZE ? ++_j : --_j) {
      for (y = _k = 0; 0 <= BOARD_SIZE ? _k < BOARD_SIZE : _k > BOARD_SIZE; y = 0 <= BOARD_SIZE ? ++_k : --_k) {
        p = [x, y];
        $intersection = $(".intersection:nth-child(" + (1 + p[0] + p[1] * BOARD_SIZE) + ")");
        place = function(blackOrWhite) {
          var deferred;
          if (effect && ((!$intersection.hasClass(blackOrWhite)) || ($intersection.hasClass('half-opacity')))) {
            deferred = $.Deferred();
            deferredes.push(deferred);
            $intersection.one($s.vendor.animationend, function() {
              $(this).removeClass('shake');
              return deferred.resolve();
            });
            return $intersection.removeClass('half-opacity').addClass("" + blackOrWhite + " shake");
          } else {
            return $intersection.removeClass('white half-opacity').addClass(blackOrWhite);
          }
        };
        if (blacks.some(function(e) {
          return e.isEqualTo(p);
        })) {
          place('black');
        } else if (whites.some(function(e) {
          return e.isEqualTo(p);
        })) {
          place('white');
        } else {
          if (effect && ($intersection.hasClass('black') || ($intersection.hasClass('white')))) {
            deferred = $.Deferred();
            deferredes.push(deferred);
            $intersection.one($s.vendor.transitionend, (function(deferred) {
              return function() {
                $(this).removeClass('black white rise');
                return deferred.resolve();
              };
            })(deferred));
            $intersection.addClass('rise');
          } else {
            $intersection.removeClass('white black half-opacity');
          }
        }
      }
    }
    if (effect) {
      return $.when.apply(window, deferredes).done(callback);
    }
  };

  openAndCloseModal = function(id, callback) {
    if (callback == null) {
      callback = function() {};
    }

    /*
    モーダルを一定時間表示する。
     */
    $("#" + id).modal('show');
    return setTimeout((function() {
      $("#" + id).modal('hide');
      return callback();
    }), responseInterval);
  };


  /*
   * 四路の碁(仮名)
   * (C) 2013 ICHIKAWA, Yuji (New 3 Rs)
   */

  userStone = BLACK;

  expected = null;

  currentIndex = 0;

  try {
    document.createEvent("TouchEvent");
    if ((window.Touch != null) && (typeof window.ontouchstart) !== 'undefined') {
      touchDevice = true;
    } else {
      false;
    }
  } catch (_error) {
    touchDevice = false;
  }

  window.printExpected = function() {
    console.log(expected.history.map(function(e) {
      return e.toString();
    }).join('\n'));
    return console.log(expected.value);
  };

  bgm = {
    element: $('#bgm')[0],
    state: 'stop',
    play: function() {
      return bgm.state = 'play';
    },
    pause: function() {
      bgm.element.pause();
      return bgm.state = 'pause';
    },
    stop: function() {
      bgm.element.pause();
      bgm.state = 'stop';
      try {
        return bgm.element.currentTime = 0;
      } catch (_error) {
        e = _error;
        return console.log(e);
      }
    }
  };

  window.onpagehide = function() {
    if (bgm.state === 'play') {
      return bgm.pause();
    }
  };

  window.onpageshow = function() {
    if (bgm.state === 'pause') {
      return bgm.play();
    }
  };

  endGame = function() {
    var score;
    bgm.stop();
    score = expected.value - expected.history[0].score();
    alert(score === 0 ? '引き分け' : score > 0 ? "黒" + score + "目勝ち" : "白" + (-score) + "目勝ち");
    return $('#start-stop').removeAttr('disabled');
  };

  computerPlay = function(board) {
    var behaveNext, score, _ref2, _ref3;
    behaveNext = function() {
      currentIndex += 1;
      if (currentIndex < expected.history.length) {
        if (board.isEqualTo(expected.history[currentIndex])) {
          return setTimeout((function() {
            var _ref2, _ref3;
            alert('パスします');
            if (((_ref2 = expected.history[currentIndex - 2]) != null ? _ref2.isEqualTo(board) : void 0) && ((_ref3 = expected.history[currentIndex - 1]) != null ? _ref3.isEqualTo(board) : void 0)) {
              return endGame();
            } else {
              return waitForUserPlay();
            }
          }), 0);
        } else {
          return showOnBoard(expected.history[currentIndex], true, waitForUserPlay);
        }
      } else {
        return endGame();
      }
    };
    if ((_ref2 = expected.history[currentIndex]) != null ? _ref2.isEqualTo(board) : void 0) {
      if (expected.history.length - 1 > currentIndex) {
        if (!((_ref3 = expected.history[currentIndex - 1]) != null ? _ref3.isEqualTo(board) : void 0)) {
          score = expected.value - expected.history[0].score();
          score = userStone === BLACK ? -score : score;
          if (score > 0) {
            return openAndCloseModal('expect-modal', behaveNext);
          } else if ((userStone === BLACK ? -expected.value : expected.value) === -MAX_SCORE) {
            return openAndCloseModal('pessimistic-modal', behaveNext);
          } else {
            return setTimeout((function() {
              return behaveNext();
            }), responseInterval);
          }
        } else {
          return setTimeout((function() {
            return behaveNext();
          }), responseInterval);
        }
      } else if (expected.value === (userStone === BLACK ? MAX_SCORE : -MAX_SCORE)) {
        bgm.stop();
        return setTimeout((function() {
          alert('負けました…');
          return $('#start-stop').removeAttr('disabled');
        }), responseInterval);
      } else {
        $('#unexpected-modal').modal('show');
        return wEvaluate(expected.history.slice(0, currentIndex).concat(board), opponentOf(userStone), (function(result) {
          expected = result;
          return behaveNext();
        }), (function(error) {
          var b, candidates, computerStone, nodes, parity, _j, _len1;
          $('#evaluate-modal').modal('hide');
          expected = {
            value: NaN,
            history: expected.history.slice(0, currentIndex).concat(board)
          };
          computerStone = opponentOf(userStone);
          candidates = board.candidates(computerStone);
          nodes = [];
          for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
            b = candidates[_j];
            parity = userStone === BLACK ? 0 : 1;
            if (expected.history.filter(function(e, i) {
              return (i % 2) === parity;
            }).every(function(e) {
              return !b.isEqualTo(e);
            })) {
              nodes.push(b);
            }
          }
          nodes.sort(function(a, b) {
            return -compare(a, b, computerStone);
          });
          expected.history.push(nodes[0]);
          return openAndCloseModal('upset-modal', behaveNext);
        }));
      }
    } else {
      return wEvaluate(expected.history.slice(0, currentIndex).concat(board), opponentOf(userStone), (function(result) {
        expected = result;
        return behaveNext();
      }), (function(error) {
        var b, candidates, computerStone, nodes, parity, _j, _len1;
        expected = {
          value: NaN,
          history: expected.history.slice(0, currentIndex).concat(board)
        };
        computerStone = opponentOf(userStone);
        candidates = board.candidates(computerStone);
        nodes = [];
        for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
          b = candidates[_j];
          parity = userStone === BLACK ? 0 : 1;
          if (expected.history.filter(function(e, i) {
            return (i % 2) === parity;
          }).every(function(e) {
            return !b.isEqualTo(e);
          })) {
            nodes.push(b);
          }
        }
        nodes.sort(function(a, b) {
          return -compare(a, b, computerStone);
        });
        expected.history.push(nodes[0]);
        return behaveNext();
      }));
    }
  };

  userPlayAndResponse = function(position) {
    var board, parity;
    $('#pass, #resign').attr('disabled', 'disabled');
    board = expected.history[currentIndex].copy();
    if (board.place(userStone, [position[0] + 1, position[1] + 1])) {
      parity = (currentIndex + 1) % 2;
      if ((position != null) && expected.history.slice(0, currentIndex).filter(function(e, i) {
        return (i % 2) === parity;
      }).some(function(e) {
        return board.isEqualTo(e);
      })) {
        alert('そこへ打つと繰り返し…');
        showOnBoard(expected.history[currentIndex]);
        return waitForUserPlay();
      } else {
        return showOnBoard(board, true, function() {
          currentIndex += 1;
          return computerPlay(board);
        });
      }
    } else {
      alert('そこは打てないよ〜');
      showOnBoard(expected.history[currentIndex]);
      return waitForUserPlay();
    }
  };

  $board = $('#board');

  if (touchDevice) {
    $(document.body).on('touchmove', function(e) {
      return e.preventDefault();
    });
    waitForUserPlay = function() {
      $board.on('touchstart', '.intersection:not(.black):not(.white)', function() {
        $board.off('touchstart', '.intersection:not(.black):not(.white)');
        $(this).addClass("" + (userStone === BLACK ? 'black' : 'white') + " half-opacity");
        $board.on('touchmove', function(e) {
          var $target, event;
          event = e.originalEvent;
          $target = $(document.elementFromPoint(event.touches[0].clientX, event.touches[0].clientY));
          if ($target.is('.intersection:not(.black):not(.white)')) {
            $target.parent().children('.half-opacity').removeClass('black white half-opacity');
            return $target.addClass("" + (userStone === BLACK ? 'black' : 'white') + " half-opacity");
          }
        });
        return $board.on('touchend touchcancel', function(e) {
          var $target, event, index;
          $board.off('touchmove touchend touchcancel');
          if (e.type === 'touchcancel') {
            return;
          }
          event = e.originalEvent;
          $target = $(document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY));
          if ($target.is('.intersection.half-opacity')) {
            index = $target.prevAll().length;
            return userPlayAndResponse.call(this, [index % BOARD_SIZE, Math.floor(index / BOARD_SIZE)]);
          }
        });
      });
      return $('#pass, #resign').removeAttr('disabled');
    };
    cancelWaiting = function() {
      $board.off('touchstart', '.intersection:not(.black):not(.white)');
      return $board.off('touchmove touchend touchcancel');
    };
  } else {
    waitForUserPlay = function() {
      $board.on('mousedown', '.intersection:not(.black):not(.white)', function() {
        $board.off('mousedown', '.intersection:not(.black):not(.white)');
        $(this).addClass("" + (userStone === BLACK ? 'black' : 'white') + " half-opacity");
        $board.on('mouseleave', '.intersection.half-opacity', function() {
          return $(this).removeClass('black white half-opacity');
        });
        $board.on('mouseenter', '.intersection:not(.black):not(.white)', function() {
          return $(this).addClass("" + (userStone === BLACK ? 'black' : 'white') + " half-opacity");
        });
        return $board.on('mouseup', '.intersection.half-opacity', function() {
          var index;
          $board.off('mouseleave', '.intersection.half-opacity');
          $board.off('mouseenter', '.intersection:not(.black):not(.white)');
          $board.off('mouseup', '.intersection.half-opacity');
          index = $(this).prevAll().length;
          return userPlayAndResponse.call(this, [index % BOARD_SIZE, Math.floor(index / BOARD_SIZE)]);
        });
      });
      return $('#pass, #resign').removeAttr('disabled');
    };
    cancelWaiting = function() {
      $board.off('mousedown', '.intersection:not(.black):not(.white)');
      $board.off('mouseleave', '.intersection.half-opacity');
      $board.off('mouseenter', '.intersection:not(.black):not(.white)');
      return $board.off('mouseup', '.intersection.half-opacity');
    };
  }

  $('#start-stop').on('click', function() {
    var board;
    showOnBoard(null);
    board = new OnBoard.random();
    expected = {
      value: NaN,
      history: [board]
    };
    currentIndex = 0;
    showOnBoard(expected.history[currentIndex]);
    return setTimeout((function() {
      return $('#select-modal').modal('show');
    }), 3000);
  });

  $('#play-white, #play-black').on('click', function() {
    $('#start-stop').attr('disabled', 'disabled');
    userStone = (function() {
      switch (this.id) {
        case 'play-white':
          return WHITE;
        case 'play-black':
          return BLACK;
        default:
          return null;
      }
    }).call(this);
    bgm.play();
    return openAndCloseModal('start-modal', function() {
      if (userStone === BLACK) {
        return waitForUserPlay();
      } else {
        return computerPlay(expected.history[currentIndex]);
      }
    });
  });

  $('#pass').on('click', function() {
    cancelWaiting();
    return userPlayAndResponse(null);
  });

  $('#resign').on('click', function() {
    cancelWaiting();
    bgm.stop();
    return openAndCloseModal('end-modal', function() {
      $('#start-stop').removeAttr('disabled');
      return $('#pass, #resign').attr('disabled', 'disabled');
    });
  });

}).call(this);
