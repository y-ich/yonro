// Generated by CoffeeScript 1.8.0

/*
碁カーネル
中国ルールを採用。ただし自殺手は着手禁止とする。
 */

(function() {
  var BLACK, BOARD_SIZE, EMPTY, MAX_SCORE, WHITE, adjacenciesAt, boardOnScreen, boardsToString, cancelMessage, e, editBoard, evaluatedResult, openAndCloseModal, opponentOf, playSequence, responseInterval, root, scheduleMessage, showOnBoard, stopEditing, wEvaluate, _i, _len, _ref;

  Array.prototype.isEqualTo = function(array) {

    /*　配列の要素すべてが等しいか否かを返す。 */
    if (this.length !== array.length) {
      return false;
    }
    return this.every(function(e, i) {
      return e === array[i];
    });
  };

  BOARD_SIZE = 4;

  MAX_SCORE = BOARD_SIZE * BOARD_SIZE - 2;

  EMPTY = 0;

  BLACK = 1;

  WHITE = 2;

  boardsToString = function(history) {
    return history.map(function(e, i) {
      return "#" + i + "\n" + (e.toString());
    }).join('\n');
  };

  opponentOf = function(stone) {

    /* 黒(BLACK)なら白(WHITE)、白(WHITE)なら黒(BLACK)を返す。 */
    switch (stone) {
      case BLACK:
        return WHITE;
      case WHITE:
        return BLACK;
      default:
        throw 'error';
    }
  };

  adjacenciesAt = function(position) {

    /* プライベート */

    /* 隣接する点の座標の配列を返す。 */
    var e, result, x, y, _i, _len, _ref;
    result = [];
    _ref = [[0, -1], [-1, 0], [1, 0], [0, 1]];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      x = position[0] + e[0];
      y = position[1] + e[1];
      if ((0 <= x && x < BOARD_SIZE) && (0 <= y && y < BOARD_SIZE)) {
        result.push([x, y]);
      }
    }
    return result;
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : typeof window !== "undefined" && window !== null ? window : {};

  _ref = ['BLACK', 'WHITE', 'EMPTY', 'BOARD_SIZE', 'MAX_SCORE', 'opponentOf', 'adjacenciesAt', 'boardsToString'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    e = _ref[_i];
    root[e] = eval(e);
  }


  /*
  四路の純碁とソルバのクライアント側共通コード
   */

  responseInterval = 2000;

  wEvaluate = function(history, next, success, error, timeout) {
    var timeid, worker;
    if (timeout == null) {
      timeout = 30000;
    }

    /*
    (web workerを使って)局面を評価する。
    
    success, errorはコールバック関数。
     */
    $('#evaluating').css('display', 'inline');
    timeid = null;
    worker = new Worker('go-worker.js');
    worker.onmessage = function(event) {
      var result;
      $('#evaluating').css('display', 'none');
      clearTimeout(timeid);
      if (event.data.error != null) {
        console.log(event.data.error);
        return error(event.data.error);
      } else {
        result = new EvaluationResult(event.data.value, event.data.history.map(function(e) {
          return OnBoard.fromString(e);
        }));
        console.log(result.toString());
        return success(result);
      }
    };
    worker.postMessage({
      history: history.map(function(e) {
        return e.toString();
      }),
      next: next
    });
    return timeid = setTimeout((function() {
      $('#evaluating').css('display', 'none');
      worker.terminate();
      console.log('timeout');
      return error({
        message: 'timeout'
      });
    }), timeout);
  };

  showOnBoard = function(board, effect, callback) {
    var $intersection, ataris, blacks, deferred, deferredes, p, place, whites, x, y, _j, _k, _ref1;
    if (effect == null) {
      effect = false;
    }
    if (callback == null) {
      callback = function() {};
    }

    /*
    boardの状態を描画する。
    boardがnullなら空の盤。
    effectをtrueにすると、今の状態からエフェクト入りで盤を変更。
     */
    if (board == null) {
      $('.intersection').removeClass('black white half-opacity beat');
      return;
    }
    _ref1 = board.deployment(), blacks = _ref1[0], whites = _ref1[1];
    ataris = board.atari();
    deferredes = [];
    for (x = _j = 0; 0 <= BOARD_SIZE ? _j < BOARD_SIZE : _j > BOARD_SIZE; x = 0 <= BOARD_SIZE ? ++_j : --_j) {
      for (y = _k = 0; 0 <= BOARD_SIZE ? _k < BOARD_SIZE : _k > BOARD_SIZE; y = 0 <= BOARD_SIZE ? ++_k : --_k) {
        p = [x, y];
        $intersection = $(".intersection:nth-child(" + (1 + p[0] + p[1] * BOARD_SIZE) + ")");
        place = function(blackOrWhite, beat) {
          var deferred;
          if (effect && ((!$intersection.hasClass(blackOrWhite)) || ($intersection.hasClass('half-opacity')))) {
            deferred = $.Deferred();
            deferredes.push(deferred);
            $intersection.one($s.vendor.animationend, function() {
              var $this;
              $this = $(this);
              $this.removeClass('shake');
              if (beat) {
                $this.addClass('beat');
              } else {
                $this.removeClass('beat');
              }
              return deferred.resolve();
            });
            return $intersection.removeClass('half-opacity').addClass("" + blackOrWhite + " shake");
          } else {
            $intersection.removeClass('black white half-opacity').addClass(blackOrWhite);
            if (beat) {
              return $intersection.addClass('beat');
            } else {
              return $intersection.removeClass('beat');
            }
          }
        };
        if (blacks.some(function(e) {
          return e.isEqualTo(p);
        })) {
          place('black', ataris.some(function(e) {
            return e.isEqualTo(p);
          }));
        } else if (whites.some(function(e) {
          return e.isEqualTo(p);
        })) {
          place('white', ataris.some(function(e) {
            return e.isEqualTo(p);
          }));
        } else {
          if (effect && ($intersection.hasClass('black') || ($intersection.hasClass('white')))) {
            deferred = $.Deferred();
            deferredes.push(deferred);
            $intersection.removeClass('beat');
            $intersection.one($s.vendor.transitionend, (function(deferred) {
              return function() {
                $(this).removeClass('black white rise');
                return deferred.resolve();
              };
            })(deferred));
            setTimeout((function($intersection) {
              return function() {
                return $intersection.addClass('rise');
              };
            })($intersection), 100);
          } else {
            $intersection.removeClass('white black half-opacity beat');
          }
        }
      }
    }
    if (effect) {
      return $.when.apply(window, deferredes).done(callback);
    }
  };

  openAndCloseModal = function(id, callback) {
    if (callback == null) {
      callback = function() {};
    }

    /*
    モーダルを一定時間表示する。
     */
    $("#" + id).modal('show');
    return setTimeout((function() {
      $("#" + id).modal('hide');
      return callback();
    }), responseInterval);
  };


  /*
  main for solver.html
   */

  evaluatedResult = null;

  boardOnScreen = function() {
    var blacks, whites;
    blacks = [];
    whites = [];
    $('.intersection').each(function(i, e) {
      var $e;
      $e = $(e);
      if ($e.hasClass('black')) {
        return blacks.push([i % BOARD_SIZE, Math.floor(i / BOARD_SIZE)]);
      } else if ($e.hasClass('white')) {
        return whites.push([i % BOARD_SIZE, Math.floor(i / BOARD_SIZE)]);
      }
    });
    return new OnBoard(blacks, whites);
  };

  editBoard = function() {
    $('#black, #white').removeAttr('disabled');
    return $('.intersection').on('click', function() {
      var $this, stone;
      $this = $(this);
      stone = $('#black-white > .active').attr('id');
      if ($this.hasClass(stone)) {
        return $this.removeClass(stone);
      } else {
        $this.removeClass('black white');
        return $this.addClass(stone);
      }
    });
  };

  stopEditing = function() {
    $('.intersection').off('click');
    return $('#black, #white').attr('disabled', 'disabled');
  };

  scheduleMessage = function() {
    var aux, messages;
    messages = [
      {
        interval: 10000,
        id: 'babble-modal1'
      }, {
        interval: 20000,
        id: 'babble-modal2'
      }, {
        interval: 30000,
        id: 'babble-modal3'
      }, {
        interval: 30000,
        id: 'babble-modal4'
      }
    ];
    aux = function(index) {
      return scheduleMessage.id = setTimeout((function() {
        openAndCloseModal(messages[index].id);
        if (index < messages.length - 1) {
          return aux(index + 1);
        }
      }), messages[index].interval);
    };
    return aux(0);
  };

  cancelMessage = function() {
    return clearTimeout(scheduleMessage.id);
  };

  playSequence = function(history) {
    var aux;
    aux = function(index) {
      return setTimeout((function() {
        if (history[index].isEqualTo(history[index - 1])) {
          openAndCloseModal(index % 2 ? 'black-pass' : 'white-pass');
        } else {
          showOnBoard(history[index], true);
        }
        if (index < history.length - 1) {
          return aux(index + 1);
        } else {
          return $('#sequence').removeAttr('disabled');
        }
      }), 2000);
    };
    showOnBoard(history[0]);
    return aux(1);
  };

  $(document.body).on('touchmove', function(e) {
    if (window.Touch) {
      return e.preventDefault();
    }
  });

  $('#reset').on('click', function() {
    return $('.intersection').removeClass('black white');
  });

  $('#solve').on('click', function() {
    stopEditing();
    return openAndCloseModal('start-modal', function() {
      wEvaluate([boardOnScreen()], BLACK, (function(result) {
        evaluatedResult = result;
        cancelMessage();
        alert(result.value > 0 ? "黒" + result.value + "目勝ちですね" : result.value < 0 ? "白" + (-result.value) + "目勝ちですね" : '引き分けですね');
        $('#sequence').removeAttr('disabled');
        return editBoard();
      }), (function(error) {
        if (error.message === 'timeout') {
          return alert('降参…');
        } else {
          return alert(error.message);
        }
      }), 120000);
      return scheduleMessage();
    });
  });

  $('#sequence').on('click', function() {
    $(this).attr('disabled', 'disabled');
    return playSequence(evaluatedResult.history);
  });

  showOnBoard(OnBoard.fromString(' XOO\n O O\nXXOO\n   O'));

  editBoard();

}).call(this);
